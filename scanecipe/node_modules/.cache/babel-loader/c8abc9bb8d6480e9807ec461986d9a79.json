{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst NoFilter = require('nofilter');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst {\n  MT,\n  NUMBYTES,\n  SHIFT32,\n  SIMPLE,\n  SYMS,\n  TAG,\n  BI\n} = constants;\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst HALF = MT.SIMPLE_FLOAT << 5 | NUMBYTES.TWO;\nconst FLOAT = MT.SIMPLE_FLOAT << 5 | NUMBYTES.FOUR;\nconst DOUBLE = MT.SIMPLE_FLOAT << 5 | NUMBYTES.EIGHT;\nconst TRUE = MT.SIMPLE_FLOAT << 5 | SIMPLE.TRUE;\nconst FALSE = MT.SIMPLE_FLOAT << 5 | SIMPLE.FALSE;\nconst UNDEFINED = MT.SIMPLE_FLOAT << 5 | SIMPLE.UNDEFINED;\nconst NULL = MT.SIMPLE_FLOAT << 5 | SIMPLE.NULL;\nconst BREAK = Buffer.from([0xff]);\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\n\nconst SEMANTIC_TYPES = {};\n/**\n * @type {SemanticMap}\n * @private\n */\n\nlet current_SEMANTIC_TYPES = {};\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\n\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number';\n  }\n\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number';\n\n    case 'float':\n      return 'float';\n\n    case 'int':\n    case 'integer':\n      return 'int';\n\n    case 'string':\n      return 'string';\n  }\n\n  throw new TypeError(`dateType invalid, got \"${str}\"`);\n}\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\n\n\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options;\n    super({ ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    this.canonical = canonical;\n    this.encodeUndefined = encodeUndefined;\n    this.disallowUndefinedKeys = disallowUndefinedKeys;\n    this.dateType = parseDateType(dateType);\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;\n    /** @type {WeakSet?} */\n\n    this.detectLoops = undefined;\n\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet();\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops;\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet');\n    }\n\n    this.omitUndefinedProperties = omitUndefinedProperties;\n    this.semanticTypes = { ...Encoder.SEMANTIC_TYPES\n    };\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1]);\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v);\n      }\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false\n\n    return cb(ret === false ? new Error('Push Error') : undefined);\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  _flush(cb) {\n    return cb();\n  }\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushInfinity(obj) {\n    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *    how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2);\n      }\n    }\n\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *    but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *    Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *    If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *    then we'll encode this as a float rather than making the number\n   *    negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj);\n    }\n\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n    }\n\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n    }\n\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n    }\n\n    let max = Number.MAX_SAFE_INTEGER;\n\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--;\n    }\n\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n    }\n\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig);\n    }\n\n    return this._pushFloat(obj);\n  }\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *    but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    }\n\n    return this._pushInt(obj, MT.POS_INT);\n  }\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN();\n    }\n\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj);\n    }\n\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj);\n    }\n\n    return this._pushFloat(obj);\n  }\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj));\n\n      case 'object':\n        {\n          const buf = utils.bufferishToBuffer(this.encodeUndefined);\n\n          if (buf) {\n            return this.push(buf);\n          }\n        }\n    }\n\n    return this.pushAny(this.encodeUndefined);\n  }\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushNull(obj) {\n    return this._pushUInt8(NULL);\n  }\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT; // BigInt doesn't have -0\n\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE;\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers && obj <= BI.MAXINT64) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m);\n      }\n\n      return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));\n    }\n\n    let str = obj.toString(16);\n\n    if (str.length % 2) {\n      str = `0${str}`;\n    }\n\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf);\n  }\n  /**\n   * @param {object} obj Object to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n\n\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts\n    };\n\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`);\n        } else {\n          this.detectLoops.add(obj);\n        }\n      }\n    }\n\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR;\n\n      if (typeof f === 'function') {\n        return f.call(obj, this);\n      }\n\n      const converter = this.semanticTypes[obj.constructor.name];\n\n      if (converter) {\n        return converter.call(obj, this, obj);\n      }\n    }\n\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k];\n      return tv !== 'function' && (!this.omitUndefinedProperties || tv !== 'undefined');\n    });\n    const cbor_keys = {};\n\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n        return a_cbor.compare(b_cbor);\n      });\n    }\n\n    if (opts.indefinite) {\n      if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n\n    let ck = null;\n\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n\n      if (this.canonical && (ck = cbor_keys[k])) {\n        if (!this.push(ck)) {\n          // Already a Buffer\n          return false;\n        }\n      } else if (!this._pushString(k)) {\n        return false;\n      }\n\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false;\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj);\n    }\n\n    return true;\n  }\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n\n\n  _encodeAll(objs) {\n    const bs = new NoFilter({\n      highWaterMark: this.readableHighWaterMark\n    });\n    this.pipe(bs);\n\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n\n    this.end();\n    return bs.read();\n  }\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n\n\n  addSemanticType(type, fun) {\n    const typeName = typeof type === 'string' ? type : type.name;\n    const old = this.semanticTypes[typeName];\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function');\n      }\n\n      this.semanticTypes[typeName] = fun;\n    } else if (old) {\n      delete this.semanticTypes[typeName];\n    }\n\n    return old;\n  }\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n\n\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n\n      case 'bigint':\n        return this._pushJSBigint(obj);\n\n      case 'string':\n        return this._pushString(obj);\n\n      case 'boolean':\n        return this._pushBoolean(obj);\n\n      case 'undefined':\n        return this._pushUndefined(obj);\n\n      case 'object':\n        return this._pushObject(obj);\n\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined);\n          // TODO: Add pluggable support for other symbols\n\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`);\n        }\n\n      default:\n        throw new TypeError(`Unknown type: ${typeof obj}, ${typeof obj.toString === 'function' ? obj.toString() : ''}`);\n    }\n  }\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n\n\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts\n    };\n    const len = obj.length;\n\n    if (opts.indefinite) {\n      if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n\n\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false;\n    }\n\n    this.detectLoops = new WeakSet();\n    return true;\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj.getTime() / 1000));\n\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj.getTime() / 1000);\n\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj.getTime() / 1000);\n    }\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen,\n    /** @type {Buffer} */\n    obj.slice());\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false;\n    }\n\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf());\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n\n\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts\n    };\n    let entries = [...obj.entries()];\n\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(_ref => {\n        let [k, v] = _ref;\n        return v !== undefined;\n      });\n    }\n\n    if (opts.indefinite) {\n      if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false;\n    } // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n\n\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops),\n        // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers\n      });\n      const bs = new NoFilter({\n        highWaterMark: gen.readableHighWaterMark\n      });\n      enc.pipe(bs);\n      entries.sort((_ref2, _ref3) => {\n        let [a] = _ref2;\n        let [b] = _ref3;\n        // Both a and b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n    let typ = 0b01000000;\n    let sz = obj.BYTES_PER_ELEMENT;\n    const {\n      name\n    } = obj.constructor;\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000;\n      sz /= 2;\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000;\n    }\n\n    if (name.includes('Clamped') || sz !== 1 && !utils.isBigEndian()) {\n      typ |= 0b00000100;\n    }\n\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11\n    }[sz];\n\n    if (!gen._pushTag(typ)) {\n      return false;\n    }\n\n    return Encoder._pushBuffer(gen, Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength));\n  }\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n\n\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj));\n  }\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n\n\n  static encodeIndefinite(gen, obj) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode');\n      }\n\n      obj = this;\n    } // TODO: consider other options\n\n\n    const {\n      chunkSize = 4096\n    } = options;\n    let ret = true;\n    const objType = typeof obj;\n    let buf = null;\n\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);\n      let offset = 0;\n\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && gen._pushString(obj.slice(offset, endIndex));\n        offset = endIndex;\n      }\n\n      ret = ret && gen.push(BREAK);\n    } else if (buf = utils.bufferishToBuffer(obj)) {\n      ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);\n      let offset = 0;\n\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex));\n        offset = endIndex;\n      }\n\n      ret = ret && gen.push(BREAK);\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true\n      });\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true\n      });\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding');\n      }\n\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true\n      });\n    }\n\n    return ret;\n  }\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n\n\n  static encode() {\n    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n      objs[_key] = arguments[_key];\n    }\n\n    return new Encoder()._encodeAll(objs);\n  }\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n\n\n  static encodeCanonical() {\n    for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      objs[_key2] = arguments[_key2];\n    }\n\n    return new Encoder({\n      canonical: true\n    })._encodeAll(objs);\n  }\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   */\n\n\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n\n\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n\n\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES;\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val;\n  }\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n\n\n  static reset() {\n    Encoder.SEMANTIC_TYPES = { ...SEMANTIC_TYPES\n    };\n  }\n\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer,\n  // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter,\n  // Mßight be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed\n}); // Safari needs to get better.\n\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;\n}\n\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;\n}\n\nEncoder.reset();\nmodule.exports = Encoder;","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/cbor/lib/encoder.js"],"names":["stream","require","NoFilter","utils","constants","MT","NUMBYTES","SHIFT32","SIMPLE","SYMS","TAG","BI","Buffer","HALF","SIMPLE_FLOAT","TWO","FLOAT","FOUR","DOUBLE","EIGHT","TRUE","FALSE","UNDEFINED","NULL","BREAK","from","BUF_NAN","BUF_INF_NEG","BUF_INF_POS","BUF_NEG_ZERO","SEMANTIC_TYPES","current_SEMANTIC_TYPES","parseDateType","str","toLowerCase","TypeError","Encoder","Transform","constructor","options","canonical","encodeUndefined","disallowUndefinedKeys","dateType","collapseBigIntegers","detectLoops","omitUndefinedProperties","genTypes","superOpts","readableObjectMode","writableObjectMode","undefined","WeakSet","semanticTypes","Array","isArray","i","len","length","addSemanticType","k","v","Object","entries","_transform","fresh","encoding","cb","ret","pushAny","Error","_flush","_pushUInt8","val","b","allocUnsafe","writeUInt8","push","_pushUInt16BE","writeUInt16BE","_pushUInt32BE","writeUInt32BE","_pushFloatBE","writeFloatBE","_pushDoubleBE","writeDoubleBE","_pushNaN","_pushInfinity","obj","half","_pushFloat","b2","writeHalf","Math","fround","_pushInt","mt","orig","m","ONE","max","Number","MAX_SAFE_INTEGER","NEG_INT","floor","_pushIntNum","is","POS_INT","_pushNumber","isNaN","isFinite","round","_pushString","byteLength","UTF8_STRING","_pushBoolean","_pushUndefined","buf","bufferishToBuffer","_pushNull","_pushTag","tag","_pushJSBigint","POS_BIGINT","MINUS_ONE","NEG_BIGINT","MAXINT64","toString","_pushBuffer","_pushObject","opts","indefinite","skipTypes","has","add","f","encodeCBOR","call","converter","name","keys","filter","tv","cbor_keys","sort","a","a_cbor","encode","b_cbor","compare","MAP","INDEFINITE","ck","j","len2","delete","_encodeAll","objs","bs","highWaterMark","readableHighWaterMark","pipe","o","end","read","type","fun","typeName","old","pushArray","gen","ARRAY","removeLoopDetectors","_pushDate","DATE_STRING","toISOString","DATE_EPOCH","getTime","BYTE_STRING","_pushNoFilter","slice","_pushRegexp","REGEXP","source","_pushSet","SET","size","x","_pushURL","URI","_pushBoxed","valueOf","_pushMap","enc","Boolean","_pushTypedArray","typ","sz","BYTES_PER_ELEMENT","startsWith","includes","isBigEndian","buffer","byteOffset","_pushArrayBuffer","encodeIndefinite","chunkSize","objType","offset","endIndex","Map","encodeCanonical","encodeOne","encodeAsync","Promise","resolve","reject","bufs","on","concat","reset","assign","Date","RegExp","Set","ArrayBuffer","Uint8ClampedArray","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","URL","String","BigUint64Array","BigInt64Array","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants\nconst {Buffer} = require('buffer')\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL\n\nconst BREAK = Buffer.from([0xff])\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {}\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {}\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number'\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number'\n    case 'float':\n      return 'float'\n    case 'int':\n    case 'integer':\n      return 'int'\n    case 'string':\n      return 'string'\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`)\n}\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    })\n\n    this.canonical = canonical\n    this.encodeUndefined = encodeUndefined\n    this.disallowUndefinedKeys = disallowUndefinedKeys\n    this.dateType = parseDateType(dateType)\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet()\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet')\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES}\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1])\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v)\n      }\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    return cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    return cb()\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *    how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *    but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *    Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *    If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *    then we'll encode this as a float rather than making the number\n   *    negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n    let max = Number.MAX_SAFE_INTEGER\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *    but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    }\n    return this._pushInt(obj, MT.POS_INT)\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN()\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj)\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj))\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined)\n        if (buf) {\n          return this.push(buf)\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    }\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`)\n        } else {\n          this.detectLoops.add(obj)\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR\n      if (typeof f === 'function') {\n        return f.call(obj, this)\n      }\n      const converter = this.semanticTypes[obj.constructor.name]\n      if (converter) {\n        return converter.call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k]\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'))\n    })\n    const cbor_keys = {}\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck = null\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false\n        }\n      } else if (!this._pushString(k)) {\n        return false\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj)\n    }\n    return true\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark})\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name\n    const old = this.semanticTypes[typeName]\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function')\n      }\n      this.semanticTypes[typeName] = fun\n    } else if (old) {\n      delete this.semanticTypes[typeName]\n    }\n    return old\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`)\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        )\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    const len = obj.length\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false\n    }\n    this.detectLoops = new WeakSet()\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000))\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000)\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000)\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()))\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    let entries = [...obj.entries()]\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([k, v]) => v !== undefined)\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      })\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000\n    let sz = obj.BYTES_PER_ELEMENT\n    const {name} = obj.constructor\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000\n      sz /= 2\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz]\n    if (!gen._pushTag(typ)) {\n      return false\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    )\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode')\n      }\n      obj = this\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options\n\n    let ret = true\n    const objType = typeof obj\n    let buf = null\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && gen._pushString(obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      })\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      })\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding')\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      })\n    }\n    return ret\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES}\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Mßight be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n})\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray\n}\n\nEncoder.reset()\nmodule.exports = Encoder\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n/**\n * sha256-uint8array.ts\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hash = exports.createHash = void 0; // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311\n\nconst K = [0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0, 0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0, 0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0, 0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0, 0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0, 0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0, 0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0, 0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0, 0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0, 0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0, 0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0, 0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0, 0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0, 0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0, 0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0, 0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0];\nconst algorithms = {\n  sha256: 1\n};\n\nfunction createHash(algorithm) {\n  if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {\n    throw new Error(\"Digest method not supported\");\n  }\n\n  return new Hash();\n}\n\nexports.createHash = createHash;\n\nclass Hash {\n  constructor() {\n    // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n    this.A = 0x6a09e667 | 0;\n    this.B = 0xbb67ae85 | 0;\n    this.C = 0x3c6ef372 | 0;\n    this.D = 0xa54ff53a | 0;\n    this.E = 0x510e527f | 0;\n    this.F = 0x9b05688c | 0;\n    this.G = 0x1f83d9ab | 0;\n    this.H = 0x5be0cd19 | 0;\n    this._size = 0;\n    this._sp = 0; // surrogate pair\n\n    if (!sharedBuffer || sharedOffset >= 8000\n    /* allocTotal */\n    ) {\n      sharedBuffer = new ArrayBuffer(8000\n      /* allocTotal */\n      );\n      sharedOffset = 0;\n    }\n\n    this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80\n    /* allocBytes */\n    );\n    this._word = new Int32Array(sharedBuffer, sharedOffset, 20\n    /* allocWords */\n    );\n    sharedOffset += 80\n    /* allocBytes */\n    ;\n  }\n\n  update(data) {\n    // data: string\n    if (\"string\" === typeof data) {\n      return this._utf8(data);\n    } // data: undefined\n\n\n    if (data == null) {\n      throw new TypeError(\"Invalid type: \" + typeof data);\n    }\n\n    const byteOffset = data.byteOffset;\n    const length = data.byteLength;\n    let blocks = length / 64\n    /* inputBytes */\n    | 0;\n    let offset = 0; // longer than 1 block\n\n    if (blocks && !(byteOffset & 3) && !(this._size % 64\n    /* inputBytes */\n    )) {\n      const block = new Int32Array(data.buffer, byteOffset, blocks * 16\n      /* inputWords */\n      );\n\n      while (blocks--) {\n        this._int32(block, offset >> 2);\n\n        offset += 64\n        /* inputBytes */\n        ;\n      }\n\n      this._size += offset;\n    } // data: TypedArray | DataView\n\n\n    const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;\n\n    if (BYTES_PER_ELEMENT !== 1 && data.buffer) {\n      const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);\n      return this._uint8(rest);\n    } // no more bytes\n\n\n    if (offset === length) return this; // data: Uint8Array | Int8Array\n\n    return this._uint8(data, offset);\n  }\n\n  _uint8(data, offset) {\n    const {\n      _byte,\n      _word\n    } = this;\n    const length = data.length;\n    offset = offset | 0;\n\n    while (offset < length) {\n      const start = this._size % 64\n      /* inputBytes */\n      ;\n      let index = start;\n\n      while (offset < length && index < 64\n      /* inputBytes */\n      ) {\n        _byte[index++] = data[offset++];\n      }\n\n      if (index >= 64\n      /* inputBytes */\n      ) {\n        this._int32(_word);\n      }\n\n      this._size += index - start;\n    }\n\n    return this;\n  }\n\n  _utf8(text) {\n    const {\n      _byte,\n      _word\n    } = this;\n    const length = text.length;\n    let surrogate = this._sp;\n\n    for (let offset = 0; offset < length;) {\n      const start = this._size % 64\n      /* inputBytes */\n      ;\n      let index = start;\n\n      while (offset < length && index < 64\n      /* inputBytes */\n      ) {\n        let code = text.charCodeAt(offset++) | 0;\n\n        if (code < 0x80) {\n          // ASCII characters\n          _byte[index++] = code;\n        } else if (code < 0x800) {\n          // 2 bytes\n          _byte[index++] = 0xC0 | code >>> 6;\n          _byte[index++] = 0x80 | code & 0x3F;\n        } else if (code < 0xD800 || code > 0xDFFF) {\n          // 3 bytes\n          _byte[index++] = 0xE0 | code >>> 12;\n          _byte[index++] = 0x80 | code >>> 6 & 0x3F;\n          _byte[index++] = 0x80 | code & 0x3F;\n        } else if (surrogate) {\n          // 4 bytes - surrogate pair\n          code = ((surrogate & 0x3FF) << 10) + (code & 0x3FF) + 0x10000;\n          _byte[index++] = 0xF0 | code >>> 18;\n          _byte[index++] = 0x80 | code >>> 12 & 0x3F;\n          _byte[index++] = 0x80 | code >>> 6 & 0x3F;\n          _byte[index++] = 0x80 | code & 0x3F;\n          surrogate = 0;\n        } else {\n          surrogate = code;\n        }\n      }\n\n      if (index >= 64\n      /* inputBytes */\n      ) {\n        this._int32(_word);\n\n        _word[0] = _word[16\n        /* inputWords */\n        ];\n      }\n\n      this._size += index - start;\n    }\n\n    this._sp = surrogate;\n    return this;\n  }\n\n  _int32(data, offset) {\n    let {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    let i = 0;\n    offset = offset | 0;\n\n    while (i < 16\n    /* inputWords */\n    ) {\n      W[i++] = swap32(data[offset++]);\n    }\n\n    for (i = 16\n    /* inputWords */\n    ; i < 64\n    /* workWords */\n    ; i++) {\n      W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;\n    }\n\n    for (i = 0; i < 64\n    /* workWords */\n    ; i++) {\n      const T1 = H + sigma1(E) + ch(E, F, G) + K[i] + W[i] | 0;\n      const T2 = sigma0(A) + maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n\n    this.A = A + this.A | 0;\n    this.B = B + this.B | 0;\n    this.C = C + this.C | 0;\n    this.D = D + this.D | 0;\n    this.E = E + this.E | 0;\n    this.F = F + this.F | 0;\n    this.G = G + this.G | 0;\n    this.H = H + this.H | 0;\n  }\n\n  digest(encoding) {\n    const {\n      _byte,\n      _word\n    } = this;\n    let i = this._size % 64\n    /* inputBytes */\n    | 0;\n    _byte[i++] = 0x80; // pad 0 for current word\n\n    while (i & 3) {\n      _byte[i++] = 0;\n    }\n\n    i >>= 2;\n\n    if (i > 14\n    /* highIndex */\n    ) {\n      while (i < 16\n      /* inputWords */\n      ) {\n        _word[i++] = 0;\n      }\n\n      i = 0;\n\n      this._int32(_word);\n    } // pad 0 for rest words\n\n\n    while (i < 16\n    /* inputWords */\n    ) {\n      _word[i++] = 0;\n    } // input size\n\n\n    const bits64 = this._size * 8;\n    const low32 = (bits64 & 0xffffffff) >>> 0;\n    const high32 = (bits64 - low32) / 0x100000000;\n    if (high32) _word[14\n    /* highIndex */\n    ] = swap32(high32);\n    if (low32) _word[15\n    /* lowIndex */\n    ] = swap32(low32);\n\n    this._int32(_word);\n\n    return encoding === \"hex\" ? this._hex() : this._bin();\n  }\n\n  _hex() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);\n  }\n\n  _bin() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H,\n      _byte,\n      _word\n    } = this;\n    _word[0] = swap32(A);\n    _word[1] = swap32(B);\n    _word[2] = swap32(C);\n    _word[3] = swap32(D);\n    _word[4] = swap32(E);\n    _word[5] = swap32(F);\n    _word[6] = swap32(G);\n    _word[7] = swap32(H);\n    return _byte.slice(0, 32);\n  }\n\n}\n\nexports.Hash = Hash;\nconst W = new Int32Array(64\n/* workWords */\n);\nlet sharedBuffer;\nlet sharedOffset = 0;\n\nconst hex32 = num => (num + 0x100000000).toString(16).substr(-8);\n\nconst swapLE = c => c << 24 & 0xff000000 | c << 8 & 0xff0000 | c >> 8 & 0xff00 | c >> 24 & 0xff;\n\nconst swapBE = c => c;\n\nconst swap32 = isBE() ? swapBE : swapLE;\n\nconst ch = (x, y, z) => z ^ x & (y ^ z);\n\nconst maj = (x, y, z) => x & y | z & (x | y);\n\nconst sigma0 = x => (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n\nconst sigma1 = x => (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n\nconst gamma0 = x => (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;\n\nconst gamma1 = x => (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;\n\nfunction isBE() {\n  const buf = new Uint8Array(new Uint16Array([0xFEFF]).buffer); // BOM\n\n  return buf[0] === 0xFE;\n}","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/sha256-uint8array/lib/sha256-uint8array.js"],"names":["Object","defineProperty","exports","value","Hash","createHash","K","algorithms","sha256","algorithm","toLowerCase","Error","constructor","A","B","C","D","E","F","G","H","_size","_sp","sharedBuffer","sharedOffset","ArrayBuffer","_byte","Uint8Array","_word","Int32Array","update","data","_utf8","TypeError","byteOffset","length","byteLength","blocks","offset","block","buffer","_int32","BYTES_PER_ELEMENT","rest","_uint8","start","index","text","surrogate","code","charCodeAt","i","W","swap32","gamma1","gamma0","T1","sigma1","ch","T2","sigma0","maj","digest","encoding","bits64","low32","high32","_hex","_bin","hex32","slice","num","toString","substr","swapLE","c","swapBE","isBE","x","y","z","buf","Uint16Array"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * sha256-uint8array.ts\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.createHash = void 0;\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311\nconst K = [\n    0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0,\n    0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0,\n    0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0,\n    0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0,\n    0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0,\n    0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0,\n    0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0,\n    0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0,\n    0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0,\n    0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0,\n    0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0,\n    0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0,\n    0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0,\n    0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0,\n    0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0,\n    0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0,\n];\nconst algorithms = {\n    sha256: 1,\n};\nfunction createHash(algorithm) {\n    if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {\n        throw new Error(\"Digest method not supported\");\n    }\n    return new Hash();\n}\nexports.createHash = createHash;\nclass Hash {\n    constructor() {\n        // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n        this.A = 0x6a09e667 | 0;\n        this.B = 0xbb67ae85 | 0;\n        this.C = 0x3c6ef372 | 0;\n        this.D = 0xa54ff53a | 0;\n        this.E = 0x510e527f | 0;\n        this.F = 0x9b05688c | 0;\n        this.G = 0x1f83d9ab | 0;\n        this.H = 0x5be0cd19 | 0;\n        this._size = 0;\n        this._sp = 0; // surrogate pair\n        if (!sharedBuffer || sharedOffset >= 8000 /* allocTotal */) {\n            sharedBuffer = new ArrayBuffer(8000 /* allocTotal */);\n            sharedOffset = 0;\n        }\n        this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80 /* allocBytes */);\n        this._word = new Int32Array(sharedBuffer, sharedOffset, 20 /* allocWords */);\n        sharedOffset += 80 /* allocBytes */;\n    }\n    update(data) {\n        // data: string\n        if (\"string\" === typeof data) {\n            return this._utf8(data);\n        }\n        // data: undefined\n        if (data == null) {\n            throw new TypeError(\"Invalid type: \" + typeof data);\n        }\n        const byteOffset = data.byteOffset;\n        const length = data.byteLength;\n        let blocks = (length / 64 /* inputBytes */) | 0;\n        let offset = 0;\n        // longer than 1 block\n        if (blocks && !(byteOffset & 3) && !(this._size % 64 /* inputBytes */)) {\n            const block = new Int32Array(data.buffer, byteOffset, blocks * 16 /* inputWords */);\n            while (blocks--) {\n                this._int32(block, offset >> 2);\n                offset += 64 /* inputBytes */;\n            }\n            this._size += offset;\n        }\n        // data: TypedArray | DataView\n        const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;\n        if (BYTES_PER_ELEMENT !== 1 && data.buffer) {\n            const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);\n            return this._uint8(rest);\n        }\n        // no more bytes\n        if (offset === length)\n            return this;\n        // data: Uint8Array | Int8Array\n        return this._uint8(data, offset);\n    }\n    _uint8(data, offset) {\n        const { _byte, _word } = this;\n        const length = data.length;\n        offset = offset | 0;\n        while (offset < length) {\n            const start = this._size % 64 /* inputBytes */;\n            let index = start;\n            while (offset < length && index < 64 /* inputBytes */) {\n                _byte[index++] = data[offset++];\n            }\n            if (index >= 64 /* inputBytes */) {\n                this._int32(_word);\n            }\n            this._size += index - start;\n        }\n        return this;\n    }\n    _utf8(text) {\n        const { _byte, _word } = this;\n        const length = text.length;\n        let surrogate = this._sp;\n        for (let offset = 0; offset < length;) {\n            const start = this._size % 64 /* inputBytes */;\n            let index = start;\n            while (offset < length && index < 64 /* inputBytes */) {\n                let code = text.charCodeAt(offset++) | 0;\n                if (code < 0x80) {\n                    // ASCII characters\n                    _byte[index++] = code;\n                }\n                else if (code < 0x800) {\n                    // 2 bytes\n                    _byte[index++] = 0xC0 | (code >>> 6);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                }\n                else if (code < 0xD800 || code > 0xDFFF) {\n                    // 3 bytes\n                    _byte[index++] = 0xE0 | (code >>> 12);\n                    _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                }\n                else if (surrogate) {\n                    // 4 bytes - surrogate pair\n                    code = ((surrogate & 0x3FF) << 10) + (code & 0x3FF) + 0x10000;\n                    _byte[index++] = 0xF0 | (code >>> 18);\n                    _byte[index++] = 0x80 | ((code >>> 12) & 0x3F);\n                    _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                    surrogate = 0;\n                }\n                else {\n                    surrogate = code;\n                }\n            }\n            if (index >= 64 /* inputBytes */) {\n                this._int32(_word);\n                _word[0] = _word[16 /* inputWords */];\n            }\n            this._size += index - start;\n        }\n        this._sp = surrogate;\n        return this;\n    }\n    _int32(data, offset) {\n        let { A, B, C, D, E, F, G, H } = this;\n        let i = 0;\n        offset = offset | 0;\n        while (i < 16 /* inputWords */) {\n            W[i++] = swap32(data[offset++]);\n        }\n        for (i = 16 /* inputWords */; i < 64 /* workWords */; i++) {\n            W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;\n        }\n        for (i = 0; i < 64 /* workWords */; i++) {\n            const T1 = (H + sigma1(E) + ch(E, F, G) + K[i] + W[i]) | 0;\n            const T2 = (sigma0(A) + maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        this.A = (A + this.A) | 0;\n        this.B = (B + this.B) | 0;\n        this.C = (C + this.C) | 0;\n        this.D = (D + this.D) | 0;\n        this.E = (E + this.E) | 0;\n        this.F = (F + this.F) | 0;\n        this.G = (G + this.G) | 0;\n        this.H = (H + this.H) | 0;\n    }\n    digest(encoding) {\n        const { _byte, _word } = this;\n        let i = (this._size % 64 /* inputBytes */) | 0;\n        _byte[i++] = 0x80;\n        // pad 0 for current word\n        while (i & 3) {\n            _byte[i++] = 0;\n        }\n        i >>= 2;\n        if (i > 14 /* highIndex */) {\n            while (i < 16 /* inputWords */) {\n                _word[i++] = 0;\n            }\n            i = 0;\n            this._int32(_word);\n        }\n        // pad 0 for rest words\n        while (i < 16 /* inputWords */) {\n            _word[i++] = 0;\n        }\n        // input size\n        const bits64 = this._size * 8;\n        const low32 = (bits64 & 0xffffffff) >>> 0;\n        const high32 = (bits64 - low32) / 0x100000000;\n        if (high32)\n            _word[14 /* highIndex */] = swap32(high32);\n        if (low32)\n            _word[15 /* lowIndex */] = swap32(low32);\n        this._int32(_word);\n        return (encoding === \"hex\") ? this._hex() : this._bin();\n    }\n    _hex() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);\n    }\n    _bin() {\n        const { A, B, C, D, E, F, G, H, _byte, _word } = this;\n        _word[0] = swap32(A);\n        _word[1] = swap32(B);\n        _word[2] = swap32(C);\n        _word[3] = swap32(D);\n        _word[4] = swap32(E);\n        _word[5] = swap32(F);\n        _word[6] = swap32(G);\n        _word[7] = swap32(H);\n        return _byte.slice(0, 32);\n    }\n}\nexports.Hash = Hash;\nconst W = new Int32Array(64 /* workWords */);\nlet sharedBuffer;\nlet sharedOffset = 0;\nconst hex32 = num => (num + 0x100000000).toString(16).substr(-8);\nconst swapLE = (c => (((c << 24) & 0xff000000) | ((c << 8) & 0xff0000) | ((c >> 8) & 0xff00) | ((c >> 24) & 0xff)));\nconst swapBE = (c => c);\nconst swap32 = isBE() ? swapBE : swapLE;\nconst ch = (x, y, z) => (z ^ (x & (y ^ z)));\nconst maj = (x, y, z) => ((x & y) | (z & (x | y)));\nconst sigma0 = x => ((x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10));\nconst sigma1 = x => ((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7));\nconst gamma0 = x => ((x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3));\nconst gamma1 = x => ((x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10));\nfunction isBE() {\n    const buf = new Uint8Array(new Uint16Array([0xFEFF]).buffer); // BOM\n    return (buf[0] === 0xFE);\n}\n"]},"metadata":{},"sourceType":"script"}
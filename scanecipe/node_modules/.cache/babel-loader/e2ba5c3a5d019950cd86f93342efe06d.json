{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst encoder = require('./encoder');\n\nconst decoder = require('./decoder');\n\nconst {\n  MT\n} = require('./constants');\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\n\n\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable);\n  }\n  /**\n   * @ignore\n   */\n\n\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64');\n  }\n  /**\n   * @ignore\n   */\n\n\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64');\n  }\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n\n\n  get(key) {\n    return super.get(CborMap._encode(key));\n  }\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n\n\n  set(key, val) {\n    return super.set(CborMap._encode(key), val);\n  }\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n\n\n  delete(key) {\n    return super.delete(CborMap._encode(key));\n  }\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n\n\n  has(key) {\n    return super.has(CborMap._encode(key));\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @yields {any} The keys of the map.\n   */\n\n\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k);\n    }\n  }\n  /* eslint-disable jsdoc/require-returns-check */\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @yields {any[]} Key value pairs.\n   * @returns {IterableIterator<any, any>} Key value pairs.\n   */\n\n\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]];\n    }\n  }\n  /* eslint-enable jsdoc/require-returns-check */\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator} Key value pairs.\n   */\n\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *  each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n\n\n  forEach(fun, thisArg) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function');\n    }\n\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this);\n    }\n  }\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n\n\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false;\n    }\n\n    if (gen.canonical) {\n      const entries = Array.from(super.entries()).map(kv => [Buffer.from(kv[0], 'base64'), kv[1]]);\n      entries.sort((a, b) => a[0].compare(b[0]));\n\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = CborMap;","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/cbor/lib/map.js"],"names":["Buffer","require","encoder","decoder","MT","CborMap","Map","constructor","iterable","_encode","key","encodeCanonical","toString","_decode","decodeFirstSync","get","set","val","delete","has","keys","k","entries","kv","Symbol","iterator","forEach","fun","thisArg","TypeError","call","encodeCBOR","gen","_pushInt","size","MAP","canonical","Array","from","map","sort","a","b","compare","push","pushAny","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {Buffer} = require('buffer')\nconst encoder = require('./encoder')\nconst decoder = require('./decoder')\nconst {MT} = require('./constants')\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable)\n  }\n\n  /**\n   * @ignore\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64')\n  }\n\n  /**\n   * @ignore\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64')\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key))\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val)\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key))\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n  has(key) {\n    return super.has(CborMap._encode(key))\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @yields {any} The keys of the map.\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k)\n    }\n  }\n\n  /* eslint-disable jsdoc/require-returns-check */\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @yields {any[]} Key value pairs.\n   * @returns {IterableIterator<any, any>} Key value pairs.\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]]\n    }\n  }\n  /* eslint-enable jsdoc/require-returns-check */\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator} Key value pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *  each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n  forEach(fun, thisArg) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function')\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this)\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]])\n      entries.sort((a, b) => a[0].compare(b[0]))\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nmodule.exports = CborMap\n"]},"metadata":{},"sourceType":"script"}
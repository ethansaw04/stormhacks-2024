{"ast":null,"code":"/**\n * Modified version of @cose-js with added support for RSASSA-PSS\n */\n\nimport * as cbor from 'cbor';\nimport webcrypto from 'isomorphic-webcrypto';\nimport * as common from './common';\nconst EMPTY_BUFFER = common.EMPTY_BUFFER;\nconst Tagged = cbor.Tagged;\nconst SignTag = 98;\nconst Sign1Tag = 18;\nfunction subtle() {\n  return webcrypto.subtle ? webcrypto.subtle : window.crypto.subtle;\n}\nconst AlgFromTags = {};\nAlgFromTags[-7] = {\n  'sign': 'ES256',\n  'digest': 'SHA-256'\n};\nAlgFromTags[-35] = {\n  'sign': 'ES384',\n  'digest': 'SHA-384'\n};\nAlgFromTags[-36] = {\n  'sign': 'ES512',\n  'digest': 'SHA-512'\n};\nAlgFromTags[-37] = {\n  'sign': 'PS256',\n  'digest': 'SHA-256'\n};\nAlgFromTags[-38] = {\n  'sign': 'PS384',\n  'digest': 'SHA-384'\n};\nAlgFromTags[-39] = {\n  'sign': 'PS512',\n  'digest': 'SHA-512'\n};\nconst COSEAlgToNodeAlg = {\n  'ES256': {\n    'sign': 'ECDSA',\n    kty: 'EC',\n    'curve': 'P-256',\n    'digest': 'SHA-256'\n  },\n  'ES384': {\n    'sign': 'ECDSA',\n    kty: 'EC',\n    'curve': 'P-384',\n    'digest': 'SHA-384'\n  },\n  'ES512': {\n    'sign': 'ECDSA',\n    kty: 'EC',\n    'curve': 'P-521',\n    'digest': 'SHA-512'\n  },\n  'PS256': {\n    'sign': 'RSA-PSS',\n    kty: 'RSA',\n    'digest': 'SHA-256',\n    saltLength: 32\n  },\n  'PS384': {\n    'sign': 'RSA-PSS',\n    kty: 'RSA',\n    'digest': 'SHA-384',\n    saltLength: 48\n  },\n  'PS512': {\n    'sign': 'RSA-PSS',\n    kty: 'RSA',\n    'digest': 'SHA-512',\n    saltLength: 64\n  }\n};\nasync function doSign(SigStructure, signer, alg) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n  let toBeSigned = cbor.encode(SigStructure);\n  let algo = {\n    name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n    namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest,\n    saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n  const importedKey = await subtle().importKey('pkcs8', signer.key.pkcs8, algo, false, ['sign']);\n  return await subtle().sign(algo, importedKey, toBeSigned);\n}\nexport function create(headers, payload, signers, options) {\n  options = options || {};\n  let u = headers.u || {};\n  let p = headers.p || {};\n  p = common.TranslateHeaders(p);\n  u = common.TranslateHeaders(u);\n  let bodyP = p || {};\n  bodyP = bodyP.size === 0 ? EMPTY_BUFFER : cbor.encode(bodyP);\n  if (Array.isArray(signers)) {\n    if (signers.length === 0) {\n      throw new Error('There has to be at least one signer');\n    }\n    if (signers.length > 1) {\n      throw new Error('Only one signer is supported');\n    }\n    // TODO handle multiple signers\n    const signer = signers[0];\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    let signerP = signer.p || {};\n    let signerU = signer.u || {};\n    signerP = common.TranslateHeaders(signerP);\n    signerU = common.TranslateHeaders(signerU);\n    const alg = signerP.get(common.HeaderParameters.alg);\n    signerP = signerP.size === 0 ? EMPTY_BUFFER : cbor.encode(signerP);\n    const SigStructure = ['Signature', bodyP, signerP, externalAAD, payload];\n    return doSign(SigStructure, signer, alg).then(sig => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n      const signed = [p, u, payload, [[signerP, signerU, sig]]];\n      return cbor.encode(options.excludetag ? signed : new Tagged(SignTag, signed));\n    });\n  } else {\n    const signer = signers;\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    const alg = p.get(common.HeaderParameters.alg) || u.get(common.HeaderParameters.alg);\n    const SigStructure = ['Signature1', bodyP, externalAAD, payload];\n    return doSign(SigStructure, signer, alg).then(sig => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n      const signed = [p, u, payload, sig];\n      return cbor.encodeCanonical(options.excludetag ? signed : new Tagged(Sign1Tag, signed));\n    });\n  }\n}\n;\nasync function doVerify(SigStructure, verifier, alg, sig) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n  const ToBeSigned = cbor.encode(SigStructure);\n  let algo = {\n    name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n    namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest,\n    saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n  let jwkData = {\n    kty: COSEAlgToNodeAlg[AlgFromTags[alg].sign].kty,\n    crv: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    e: verifier.jwk.e,\n    n: verifier.jwk.n,\n    x: verifier.jwk.x,\n    y: verifier.jwk.y\n  };\n  const importedKey = await subtle().importKey('jwk', jwkData, algo, false, ['verify']);\n  return await subtle().verify(algo, importedKey, sig, ToBeSigned);\n}\nfunction getSigner(signers, verifier) {\n  for (let i = 0; i < signers.length; i++) {\n    const kid = signers[i][1].get(common.HeaderParameters.kid); // TODO create constant for header locations\n    if (kid.equals(Buffer.from(verifier.jwk.kid, 'utf8'))) {\n      return signers[i];\n    }\n  }\n}\nfunction getCommonParameter(first, second, parameter) {\n  let result;\n  if (first.get) {\n    result = first.get(parameter);\n  }\n  if (!result && second.get) {\n    result = second.get(parameter);\n  }\n  return result;\n}\nexport function verify(payload, verifier, publicKeyPem, options) {\n  options = options || {};\n  return cbor.decodeFirst(payload).then(obj => {\n    let type = options.defaultType ? options.defaultType : SignTag;\n    if (obj instanceof Tagged) {\n      if (obj.tag !== SignTag && obj.tag !== Sign1Tag) {\n        throw new Error('Unexpected cbor tag, \\'' + obj.tag + '\\'');\n      }\n      type = obj.tag;\n      obj = obj.value;\n    }\n    if (!Array.isArray(obj)) {\n      throw new Error('Expecting Array');\n    }\n    if (obj.length !== 4) {\n      throw new Error('Expecting Array of lenght 4');\n    }\n    let [p, u, plaintext, signers] = obj;\n    if (type === SignTag && !Array.isArray(signers)) {\n      throw new Error('Expecting signature Array');\n    }\n    p = !p.length ? EMPTY_BUFFER : cbor.decodeFirstSync(p);\n    u = !u.size ? EMPTY_BUFFER : u;\n    let signer = type === SignTag ? getSigner(signers, verifier) : signers;\n    if (!signer) {\n      throw new Error('Failed to find signer with kid' + verifier.key.kid);\n    }\n    if (type === SignTag) {\n      const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n      let [signerP,, sig] = signer;\n      signerP = !signerP.length ? EMPTY_BUFFER : signerP;\n      p = !p.size ? EMPTY_BUFFER : cbor.encode(p);\n      const signerPMap = cbor.decode(signerP);\n      const alg = signerPMap.get(common.HeaderParameters.alg);\n      const SigStructure = ['Signature', p, signerP, externalAAD, plaintext];\n      return doVerify(SigStructure, verifier, alg, sig).then(() => {\n        return plaintext;\n      });\n    } else {\n      const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n      const alg = getCommonParameter(p, u, common.HeaderParameters.alg);\n      p = !p.size ? EMPTY_BUFFER : cbor.encode(p);\n      const SigStructure = ['Signature1', p, externalAAD, plaintext];\n      return doVerify(SigStructure, verifier, alg, signer, publicKeyPem).then(verified => {\n        if (verified) return plaintext;else return undefined;\n      });\n    }\n  });\n}\n;","map":{"version":3,"names":["cbor","webcrypto","common","EMPTY_BUFFER","Tagged","SignTag","Sign1Tag","subtle","window","crypto","AlgFromTags","COSEAlgToNodeAlg","kty","saltLength","doSign","SigStructure","signer","alg","Error","sign","toBeSigned","encode","algo","name","namedCurve","curve","hash","digest","importedKey","importKey","key","pkcs8","create","headers","payload","signers","options","u","p","TranslateHeaders","bodyP","size","Array","isArray","length","externalAAD","signerP","signerU","get","HeaderParameters","then","sig","encodep","signed","excludetag","encodeCanonical","doVerify","verifier","ToBeSigned","jwkData","crv","e","jwk","n","x","y","verify","getSigner","i","kid","equals","Buffer","from","getCommonParameter","first","second","parameter","result","publicKeyPem","decodeFirst","obj","type","defaultType","tag","value","plaintext","decodeFirstSync","signerPMap","decode","verified","undefined"],"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/@pathcheck/dcc-sdk/lib/cose-js/sign.js"],"sourcesContent":["/**\n * Modified version of @cose-js with added support for RSASSA-PSS\n */\n\nimport * as cbor from 'cbor';\nimport webcrypto from 'isomorphic-webcrypto';\nimport * as common from './common';\n\nconst EMPTY_BUFFER = common.EMPTY_BUFFER;\nconst Tagged = cbor.Tagged;\n\nconst SignTag = 98;\nconst Sign1Tag = 18;\n\nfunction subtle() {\n  return webcrypto.subtle ? webcrypto.subtle : window.crypto.subtle;\n}\n\nconst AlgFromTags = {};\nAlgFromTags[-7] = { 'sign': 'ES256', 'digest': 'SHA-256' };  \nAlgFromTags[-35] = { 'sign': 'ES384', 'digest': 'SHA-384' };\nAlgFromTags[-36] = { 'sign': 'ES512', 'digest': 'SHA-512' };\nAlgFromTags[-37] = { 'sign': 'PS256', 'digest': 'SHA-256' };\nAlgFromTags[-38] = { 'sign': 'PS384', 'digest': 'SHA-384' };\nAlgFromTags[-39] = { 'sign': 'PS512', 'digest': 'SHA-512' };\n\nconst COSEAlgToNodeAlg = {\n  'ES256': { 'sign': 'ECDSA', kty: 'EC', 'curve': 'P-256', 'digest': 'SHA-256' },\n  'ES384': { 'sign': 'ECDSA', kty: 'EC', 'curve': 'P-384', 'digest': 'SHA-384' },\n  'ES512': { 'sign': 'ECDSA', kty: 'EC', 'curve': 'P-521', 'digest': 'SHA-512' },\n  'PS256': { 'sign': 'RSA-PSS', kty: 'RSA', 'digest': 'SHA-256', saltLength: 32  },\n  'PS384': { 'sign': 'RSA-PSS', kty: 'RSA', 'digest': 'SHA-384', saltLength: 48  },\n  'PS512': { 'sign': 'RSA-PSS', kty: 'RSA', 'digest': 'SHA-512', saltLength: 64  }\n};\n\nasync function doSign (SigStructure, signer, alg) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n\n  let toBeSigned = cbor.encode(SigStructure);\n  let algo = {\n      name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n      namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n      hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest, \n      saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n\n  const importedKey = await subtle().importKey('pkcs8', signer.key.pkcs8, algo, false, ['sign']); \n  return await subtle().sign(algo, importedKey, toBeSigned);\n}\n\nexport function create(headers, payload, signers, options) {\n  options = options || {};\n  let u = headers.u || {};\n  let p = headers.p || {};\n\n  p = common.TranslateHeaders(p);\n  u = common.TranslateHeaders(u);\n  let bodyP = p || {};\n  bodyP = (bodyP.size === 0) ? EMPTY_BUFFER : cbor.encode(bodyP);\n  if (Array.isArray(signers)) {\n    if (signers.length === 0) {\n      throw new Error('There has to be at least one signer');\n    }\n    if (signers.length > 1) {\n      throw new Error('Only one signer is supported');\n    }\n    // TODO handle multiple signers\n    const signer = signers[0];\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    let signerP = signer.p || {};\n    let signerU = signer.u || {};\n\n    signerP = common.TranslateHeaders(signerP);\n    signerU = common.TranslateHeaders(signerU);\n    const alg = signerP.get(common.HeaderParameters.alg);\n    signerP = (signerP.size === 0) ? EMPTY_BUFFER : cbor.encode(signerP);\n\n    const SigStructure = [\n      'Signature',\n      bodyP,\n      signerP,\n      externalAAD,\n      payload\n    ];\n    return doSign(SigStructure, signer, alg).then((sig) => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n      const signed = [p, u, payload, [[signerP, signerU, sig]]];\n      return cbor.encode(options.excludetag ? signed : new Tagged(SignTag, signed));\n    });\n  } else {\n    const signer = signers;\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    const alg = p.get(common.HeaderParameters.alg) || u.get(common.HeaderParameters.alg);\n    const SigStructure = [\n      'Signature1',\n      bodyP,\n      externalAAD,\n      payload\n    ];\n    return doSign(SigStructure, signer, alg).then((sig) => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n      const signed = [p, u, payload, sig];\n      return cbor.encodeCanonical(options.excludetag ? signed : new Tagged(Sign1Tag, signed));\n    });\n  }\n};\n\nasync function doVerify (SigStructure, verifier, alg, sig) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n  const ToBeSigned = cbor.encode(SigStructure);\n\n  let algo = {\n      name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n      namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n      hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest, \n      saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n\n  let jwkData = {\n    kty: COSEAlgToNodeAlg[AlgFromTags[alg].sign].kty,\n    crv: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    e: verifier.jwk.e,\n    n: verifier.jwk.n,\n    x: verifier.jwk.x,\n    y: verifier.jwk.y\n  };\n\n  const importedKey = await subtle().importKey('jwk', jwkData, algo, false, ['verify']);\n  return await subtle().verify(algo, importedKey, sig, ToBeSigned); \n}\n\nfunction getSigner (signers, verifier) {\n  for (let i = 0; i < signers.length; i++) {\n    const kid = signers[i][1].get(common.HeaderParameters.kid); // TODO create constant for header locations\n    if (kid.equals(Buffer.from(verifier.jwk.kid, 'utf8'))) {\n      return signers[i];\n    }\n  }\n}\n\nfunction getCommonParameter (first, second, parameter) {\n  let result;\n  if (first.get) {\n    result = first.get(parameter);\n  }\n  if (!result && second.get) {\n    result = second.get(parameter);\n  }\n  return result;\n}\n\nexport function verify(payload, verifier, publicKeyPem, options) {\n  options = options || {};\n  return cbor.decodeFirst(payload)\n    .then((obj) => {\n      let type = options.defaultType ? options.defaultType : SignTag;\n      if (obj instanceof Tagged) {\n        if (obj.tag !== SignTag && obj.tag !== Sign1Tag) {\n          throw new Error('Unexpected cbor tag, \\'' + obj.tag + '\\'');\n        }\n        type = obj.tag;\n        obj = obj.value;\n      }\n\n      if (!Array.isArray(obj)) {\n        throw new Error('Expecting Array');\n      }\n\n      if (obj.length !== 4) {\n        throw new Error('Expecting Array of lenght 4');\n      }\n\n      let [p, u, plaintext, signers] = obj;\n\n      if (type === SignTag && !Array.isArray(signers)) {\n        throw new Error('Expecting signature Array');\n      }\n\n      p = (!p.length) ? EMPTY_BUFFER : cbor.decodeFirstSync(p);\n      u = (!u.size) ? EMPTY_BUFFER : u;\n\n      let signer = (type === SignTag ? getSigner(signers, verifier) : signers);\n\n      if (!signer) {\n        throw new Error('Failed to find signer with kid' + verifier.key.kid);\n      }\n\n      if (type === SignTag) {\n        const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n        let [signerP, , sig] = signer;\n        signerP = (!signerP.length) ? EMPTY_BUFFER : signerP;\n        p = (!p.size) ? EMPTY_BUFFER : cbor.encode(p);\n        const signerPMap = cbor.decode(signerP);\n        const alg = signerPMap.get(common.HeaderParameters.alg);\n        const SigStructure = [\n          'Signature',\n          p,\n          signerP,\n          externalAAD,\n          plaintext\n        ];\n        return doVerify(SigStructure, verifier, alg, sig)\n          .then(() => {\n            return plaintext;\n          });\n      } else {\n        const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n\n        const alg = getCommonParameter(p, u, common.HeaderParameters.alg);\n        p = (!p.size) ? EMPTY_BUFFER : cbor.encode(p);\n        const SigStructure = [\n          'Signature1',\n          p,\n          externalAAD,\n          plaintext\n        ];\n        return doVerify(SigStructure, verifier, alg, signer, publicKeyPem)\n          .then((verified) => {\n            if (verified) \n              return plaintext;\n            else\n              return undefined;\n          });\n      }\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
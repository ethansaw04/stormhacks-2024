{"ast":null,"code":"// Needs to import only the sign and verify functions, not the encrypt and decrypt due to additional dependencies. \nimport * as cose from './cose-js/sign.js';\nimport { createHash as rawHash } from \"sha256-uint8array\";\nimport zlib from 'pako';\nimport * as cbor from 'cbor';\nimport * as base64 from 'base64-js';\nimport base45 from 'base45';\nimport { resolveKey, addCachedCerts, addCachedKeys } from './resolver';\nimport { getJWTFromPEM, getDERFromPEM } from './key-parser';\nconst URI_SCHEMA = 'HC1';\nconst CWT_ISSUER = 1;\nconst CWT_SUBJECT = 2;\nconst CWT_AUDIENCE = 3;\nconst CWT_EXPIRATION = 4;\nconst CWT_NOT_BEFORE = 5;\nconst CWT_ISSUED_AT = 6;\nconst CWT_ID = 7;\nconst CWT_HCERT = -260;\nconst CWT_HCERT_V1 = 1;\nconst CWT_STRING_PAYLOAD = 99;\nconst COSE_ALG_TAG = 1;\nconst COSE_KID_TAG = 4;\nconst NOT_SUPPORTED = \"not_supported\"; // QR Standard not supported by this algorithm\nconst INVALID_ENCODING = \"invalid_encoding\"; // could not decode Base45 for DCC, Base10 for SHC\nconst INVALID_COMPRESSION = \"invalid_compression\"; // could not decompress the byte array\nconst INVALID_SIGNING_FORMAT = \"invalid_signing_format\"; // invalid COSE, JOSE, W3C VC Payload\nconst KID_NOT_INCLUDED = \"kid_not_included\"; // unable to resolve the issuer ID\nconst ISSUER_NOT_TRUSTED = \"issuer_not_trusted\"; // issuer is not found in the registry\nconst TERMINATED_KEYS = \"terminated_keys\"; // issuer was terminated by the registry\nconst EXPIRED_KEYS = \"expired_keys\"; // keys expired\nconst REVOKED_KEYS = \"revoked_keys\"; // keys were revoked by the issuer\nconst INVALID_SIGNATURE = \"invalid_signature\"; // signature doesn't match\nconst VERIFIED = \"verified\"; // Verified content.\n\nfunction getKeyIDFromPEM(pem) {\n  return rawHash().update(getDERFromPEM(pem)).digest().slice(0, 8);\n}\nexport async function sign(payload, publicKeyPem, privateKeyP8) {\n  const jwt = getJWTFromPEM(publicKeyPem);\n  const keyId = getKeyIDFromPEM(publicKeyPem);\n  const headers = {\n    'p': {\n      'alg': jwt.alg,\n      'kid': keyId\n    },\n    'u': {}\n  };\n  const signer = {\n    'key': {\n      'pkcs8': getDERFromPEM(privateKeyP8)\n    }\n  };\n  const cborPayload = cbor.encode(payload);\n  return cose.create(headers, cborPayload, signer);\n}\n\n/*\n * I am not sure if I should build this by hand. \n */\nexport async function makeCWT(payload, monthsToExpire, issuer) {\n  let cwt = new Map();\n  let iss = new Date();\n  cwt.set(CWT_ISSUED_AT, Math.round(iss.getTime() / 1000));\n  if (monthsToExpire) {\n    let exp = new Date(iss);\n    exp.setMonth(exp.getMonth() + monthsToExpire);\n    cwt.set(CWT_EXPIRATION, Math.round(exp.getTime() / 1000));\n  }\n  if (issuer) {\n    cwt.set(CWT_ISSUER, issuer);\n  }\n  cwt.set(CWT_HCERT, new Map());\n  cwt.get(CWT_HCERT).set(CWT_HCERT_V1, payload);\n  return cwt;\n}\nexport async function parseCWT(cwt) {\n  if (cwt.get(CWT_HCERT)) return cwt.get(CWT_HCERT).get(CWT_HCERT_V1);else return JSON.parse(cwt.get(CWT_STRING_PAYLOAD));\n}\nfunction toBase64(bytes) {\n  return base64.fromByteArray(bytes);\n}\nfunction toBase64URL(bytes) {\n  return toBase64(bytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=+$/m, '');\n}\nfunction getCOSEHeaderParams(header) {\n  let headerObj;\n  // Sometimes the header has to be decoded. \n  if (header instanceof Buffer || header instanceof Uint8Array) {\n    if (header.length == 0) {\n      return {};\n    }\n    headerObj = cbor.decode(header);\n  }\n\n  // Sometimes the header is already decoded. \n  if (header instanceof Map) {\n    headerObj = header;\n  }\n  if (headerObj) {\n    let algorithm;\n    let kid;\n    if (headerObj.get(COSE_ALG_TAG)) algorithm = headerObj.get(COSE_ALG_TAG);\n    if (headerObj.get(COSE_KID_TAG)) kid = new Uint8Array(headerObj.get(COSE_KID_TAG));\n    return {\n      alg: algorithm,\n      kid: kid\n    };\n  }\n  return {};\n}\nasync function getIssuerKeyId(coseContent) {\n  let cborObj = cbor.decode(new Uint8Array(coseContent));\n  if (!cborObj) {\n    console.log(\"Not a readable COSE\");\n    return undefined;\n  }\n  let cborObjValue = cborObj.value;\n  if (!cborObjValue) {\n    if (Array.isArray(cborObj)) {\n      console.warn(\"COSE object with no Value field\", cborObj);\n      cborObjValue = cborObj;\n    } else {\n      console.log(\"COSE object with no Value field and no array\", cborObj);\n      return undefined;\n    }\n  }\n  let [protec, unprotec, payload, signature] = cborObjValue;\n  let cwtIssuer;\n  try {\n    let decodedPayload = cbor.decode(payload);\n    if (decodedPayload instanceof Map) {\n      cwtIssuer = decodedPayload.get(CWT_ISSUER);\n    }\n  } catch (err) {\n    console.log(payload, err);\n  }\n  let protectedData = getCOSEHeaderParams(protec);\n  let unProtectedData = getCOSEHeaderParams(unprotec);\n  return {\n    alg: protectedData.alg ? protectedData.alg : unProtectedData.alg,\n    kid: protectedData.kid ? protectedData.kid : unProtectedData.kid,\n    iss: cwtIssuer\n  };\n}\nexport async function verify(coseContent, addPublicKeyPem) {\n  let rawContents;\n  let plainObj;\n  try {\n    rawContents = await decodeCbor(coseContent);\n    let obj = await cbor.decodeFirst(coseContent);\n    if (obj.tag) {\n      obj = obj.value;\n    }\n    let [p, u, plaintext, signers] = obj;\n    plainObj = cbor.decode(plaintext);\n    if (!rawContents || !plaintext) {\n      return {\n        status: INVALID_SIGNING_FORMAT,\n        raw: rawContents\n      };\n    }\n  } catch (err) {\n    console.log(err);\n    return {\n      status: INVALID_SIGNING_FORMAT,\n      raw: rawContents\n    };\n  }\n  const keyID = await getIssuerKeyId(coseContent);\n  if (!keyID || !keyID.kid) return {\n    status: KID_NOT_INCLUDED,\n    contents: plainObj,\n    raw: rawContents\n  };\n\n  // Tries B64URL First\n  let issuer = await resolveKey(toBase64(keyID.kid));\n\n  // if not then use the key passed on the parameter. \n  if (!issuer && addPublicKeyPem) {\n    issuer = {\n      didDocument: addPublicKeyPem,\n      status: \"current\"\n    };\n  }\n  if (!issuer) {\n    return {\n      status: ISSUER_NOT_TRUSTED,\n      contents: plainObj,\n      raw: rawContents\n    };\n  }\n  let jwk = getJWTFromPEM(issuer.didDocument);\n  switch (issuer.status) {\n    case \"revoked\":\n      return {\n        status: REVOKED_KEYS,\n        contents: plainObj,\n        issuer: issuer,\n        raw: rawContents\n      };\n    case \"terminated\":\n      return {\n        status: TERMINATED_KEYS,\n        contents: plainObj,\n        issuer: issuer,\n        raw: rawContents\n      };\n    case \"expired\":\n      return {\n        status: EXPIRED_KEYS,\n        contents: plainObj,\n        issuer: issuer,\n        raw: rawContents\n      };\n  }\n  try {\n    jwk.kid = toBase64(keyID.kid);\n    const verified = await cose.verify(coseContent, {\n      'jwk': jwk\n    });\n    return {\n      status: VERIFIED,\n      contents: cbor.decode(verified),\n      issuer: issuer,\n      raw: rawContents\n    };\n  } catch (err) {\n    return {\n      status: INVALID_SIGNATURE,\n      contents: plainObj,\n      issuer: issuer,\n      raw: rawContents\n    };\n  }\n}\nfunction removePrefix(uri) {\n  let data = uri;\n\n  // Backwards compatibility.\n  if (data.startsWith(URI_SCHEMA)) {\n    data = data.substring(3);\n    if (data.startsWith(':')) {\n      data = data.substring(1);\n    } else {\n      console.warn(\"Warning: unsafe HC1: header from older versions\");\n    }\n    ;\n  } else {\n    console.warn(\"Warning: no HC1: header from older versions\");\n  }\n  ;\n  return data;\n}\nexport async function unpack(uri) {\n  const data = removePrefix(uri);\n  try {\n    let unencodedData = base45.decode(data);\n\n    // Check if it was zipped (Backwards compatibility.)\n    if (unencodedData[0] == 0x78) {\n      unencodedData = zlib.inflate(unencodedData);\n    }\n    return unencodedData;\n  } catch (err) {\n    console.log(err);\n    return;\n  }\n}\nasync function decodeCbor(cborObj) {\n  if (cborObj instanceof Buffer || cborObj instanceof Uint8Array) {\n    try {\n      cborObj = cbor.decode(cborObj);\n      for (var key in cborObj) {\n        cborObj[key] = await decodeCbor(cborObj[key]);\n      }\n    } catch {\n      cborObj = cborObj.toString('base64');\n    }\n  }\n  if (Array.isArray(cborObj)) {\n    for (let i = 0; i < cborObj.length; i++) {\n      cborObj[i] = await decodeCbor(cborObj[i]);\n    }\n  }\n  if (cborObj instanceof Map) {\n    for (const [key, value] of cborObj.entries()) {\n      cborObj.set(key, await decodeCbor(cborObj.get(key)));\n    }\n  }\n  return cborObj;\n}\nexport async function debug(uri) {\n  return await decodeCbor(await unpack(uri));\n}\nexport async function unpackAndVerify(uri, publicKeyPem) {\n  const data = removePrefix(uri);\n  try {\n    // Checks if the data is Base45\n    base45.decode(data);\n  } catch (err) {\n    console.log(err);\n    return {\n      status: INVALID_ENCODING,\n      qr: uri\n    };\n  }\n  const cbor = await unpack(uri);\n  if (!cbor) {\n    return {\n      status: INVALID_COMPRESSION,\n      qr: uri\n    };\n  }\n  const verified = await verify(cbor, publicKeyPem);\n  return {\n    ...verified,\n    qr: uri\n  };\n}\nexport async function pack(payload) {\n  const zipped = zlib.deflate(payload);\n  return URI_SCHEMA + ':' + base45.encode(zipped);\n}\nexport async function signAndPack(payload, publicKeyPem, privateKeyP8) {\n  return await pack(await sign(payload, publicKeyPem, privateKeyP8));\n}\nexport { addCachedCerts, addCachedKeys };","map":{"version":3,"names":["cose","createHash","rawHash","zlib","cbor","base64","base45","resolveKey","addCachedCerts","addCachedKeys","getJWTFromPEM","getDERFromPEM","URI_SCHEMA","CWT_ISSUER","CWT_SUBJECT","CWT_AUDIENCE","CWT_EXPIRATION","CWT_NOT_BEFORE","CWT_ISSUED_AT","CWT_ID","CWT_HCERT","CWT_HCERT_V1","CWT_STRING_PAYLOAD","COSE_ALG_TAG","COSE_KID_TAG","NOT_SUPPORTED","INVALID_ENCODING","INVALID_COMPRESSION","INVALID_SIGNING_FORMAT","KID_NOT_INCLUDED","ISSUER_NOT_TRUSTED","TERMINATED_KEYS","EXPIRED_KEYS","REVOKED_KEYS","INVALID_SIGNATURE","VERIFIED","getKeyIDFromPEM","pem","update","digest","slice","sign","payload","publicKeyPem","privateKeyP8","jwt","keyId","headers","alg","signer","cborPayload","encode","create","makeCWT","monthsToExpire","issuer","cwt","Map","iss","Date","set","Math","round","getTime","exp","setMonth","getMonth","get","parseCWT","JSON","parse","toBase64","bytes","fromByteArray","toBase64URL","replace","getCOSEHeaderParams","header","headerObj","Buffer","Uint8Array","length","decode","algorithm","kid","getIssuerKeyId","coseContent","cborObj","console","log","undefined","cborObjValue","value","Array","isArray","warn","protec","unprotec","signature","cwtIssuer","decodedPayload","err","protectedData","unProtectedData","verify","addPublicKeyPem","rawContents","plainObj","decodeCbor","obj","decodeFirst","tag","p","u","plaintext","signers","status","raw","keyID","contents","didDocument","jwk","verified","removePrefix","uri","data","startsWith","substring","unpack","unencodedData","inflate","key","toString","i","entries","debug","unpackAndVerify","qr","pack","zipped","deflate","signAndPack"],"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/@pathcheck/dcc-sdk/lib/dcc.js"],"sourcesContent":["// Needs to import only the sign and verify functions, not the encrypt and decrypt due to additional dependencies. \nimport * as cose from './cose-js/sign.js'\nimport {createHash as rawHash} from \"sha256-uint8array\";\n\nimport zlib from 'pako';\nimport * as cbor from 'cbor';\n\nimport * as base64 from 'base64-js';\n\nimport base45 from 'base45';\n\nimport { resolveKey, addCachedCerts, addCachedKeys } from './resolver'; \nimport { getJWTFromPEM, getDERFromPEM } from './key-parser';\n\nconst URI_SCHEMA = 'HC1';\n\nconst CWT_ISSUER = 1;\nconst CWT_SUBJECT = 2;\nconst CWT_AUDIENCE = 3;\nconst CWT_EXPIRATION = 4;\nconst CWT_NOT_BEFORE = 5;\nconst CWT_ISSUED_AT = 6;\nconst CWT_ID = 7;\nconst CWT_HCERT = -260;\nconst CWT_HCERT_V1 = 1;\n\nconst CWT_STRING_PAYLOAD = 99;\n\nconst COSE_ALG_TAG = 1;\nconst COSE_KID_TAG = 4;\n\nconst NOT_SUPPORTED = \"not_supported\";                  // QR Standard not supported by this algorithm\nconst INVALID_ENCODING = \"invalid_encoding\";            // could not decode Base45 for DCC, Base10 for SHC\nconst INVALID_COMPRESSION = \"invalid_compression\";      // could not decompress the byte array\nconst INVALID_SIGNING_FORMAT = \"invalid_signing_format\";// invalid COSE, JOSE, W3C VC Payload\nconst KID_NOT_INCLUDED = \"kid_not_included\";            // unable to resolve the issuer ID\nconst ISSUER_NOT_TRUSTED = \"issuer_not_trusted\";        // issuer is not found in the registry\nconst TERMINATED_KEYS = \"terminated_keys\";              // issuer was terminated by the registry\nconst EXPIRED_KEYS = \"expired_keys\";                    // keys expired\nconst REVOKED_KEYS = \"revoked_keys\";                    // keys were revoked by the issuer\nconst INVALID_SIGNATURE = \"invalid_signature\";          // signature doesn't match\nconst VERIFIED = \"verified\";                            // Verified content.\n\nfunction getKeyIDFromPEM(pem) {\n  return rawHash().update(getDERFromPEM(pem)).digest().slice(0,8);\n}\n\nexport async function sign(payload, publicKeyPem, privateKeyP8) {\n  const jwt = getJWTFromPEM(publicKeyPem);\n  const keyId = getKeyIDFromPEM(publicKeyPem);\n\n  const headers = {\n    'p': { \n      'alg': jwt.alg, \n      'kid': keyId \n    }, \n    'u': {}\n  };\n\n  const signer = {\n    'key': {\n      'pkcs8': getDERFromPEM(privateKeyP8) \n    }\n  };\n\n  const cborPayload = cbor.encode(payload);\n  return cose.create(headers, cborPayload, signer);\n}\n\n/*\n * I am not sure if I should build this by hand. \n */\nexport async function makeCWT(payload, monthsToExpire, issuer) {\n  let cwt = new Map();\n\n  let iss = new Date();\n  cwt.set(CWT_ISSUED_AT, Math.round(iss.getTime()/1000));\n\n  if (monthsToExpire) {\n    let exp = new Date(iss);\n    exp.setMonth(exp.getMonth()+monthsToExpire);\n    cwt.set(CWT_EXPIRATION, Math.round(exp.getTime()/1000));\n  }\n  \n  if (issuer) {\n    cwt.set(CWT_ISSUER, issuer);\n  }\n\n  cwt.set(CWT_HCERT, new Map()); \n  cwt.get(CWT_HCERT).set(CWT_HCERT_V1, payload);  \n  return cwt;\n}\n\nexport async function parseCWT(cwt) {\n  if (cwt.get(CWT_HCERT))\n    return cwt.get(CWT_HCERT).get(CWT_HCERT_V1);\n  else \n    return JSON.parse(cwt.get(CWT_STRING_PAYLOAD))\n}\n\nfunction toBase64(bytes) {\n  return base64.fromByteArray(bytes);\n}\n\nfunction toBase64URL(bytes) {\n  return toBase64(bytes).replace(/\\+/g,'-').replace(/\\//g,'_').replace(/\\=+$/m,'');\n}\n\nfunction getCOSEHeaderParams(header) {\n  let headerObj;\n  // Sometimes the header has to be decoded. \n  if (header instanceof Buffer || header  instanceof Uint8Array) {\n    if (header.length == 0) {\n      return {};\n    }\n    headerObj = cbor.decode(header);\n  } \n\n  // Sometimes the header is already decoded. \n  if (header instanceof Map) {\n    headerObj = header;\n  }\n\n  if (headerObj) {\n    let algorithm;\n    let kid; \n\n    if (headerObj.get(COSE_ALG_TAG))\n      algorithm = headerObj.get(COSE_ALG_TAG);\n    if (headerObj.get(COSE_KID_TAG))\n      kid = new Uint8Array(headerObj.get(COSE_KID_TAG));\n\n    return {alg: algorithm, kid: kid};\n  }\n  return {};\n} \n\nasync function getIssuerKeyId(coseContent) {\n  let cborObj = cbor.decode(new Uint8Array(coseContent));\n\n  if (!cborObj) { \n    console.log(\"Not a readable COSE\");\n    return undefined;\n  }\n\n  let cborObjValue = cborObj.value;\n\n  if (!cborObjValue) { \n    if (Array.isArray(cborObj)) {\n      console.warn(\"COSE object with no Value field\", cborObj);\n      cborObjValue = cborObj;\n    } else { \n      console.log(\"COSE object with no Value field and no array\", cborObj);\n      return undefined;\n    }\n  }  \n\n  let [protec, unprotec, payload, signature] = cborObjValue;\n\n  let cwtIssuer;\n\n  try {\n    let decodedPayload = cbor.decode(payload); \n    if (decodedPayload instanceof Map) {\n      cwtIssuer = decodedPayload.get(CWT_ISSUER);\n    }\n  } catch (err) {\n    console.log(payload, err);\n  }\n\n  let protectedData = getCOSEHeaderParams(protec);\n  let unProtectedData = getCOSEHeaderParams(unprotec);\n\n  return {\n    alg: protectedData.alg ? protectedData.alg : unProtectedData.alg, \n    kid: protectedData.kid ? protectedData.kid : unProtectedData.kid, \n    iss: cwtIssuer\n  };\n}\n\nexport async function verify(coseContent, addPublicKeyPem) {\n  let rawContents\n  let plainObj\n  try {\n    rawContents = await decodeCbor(coseContent);\n    let obj = await cbor.decodeFirst(coseContent)\n    if (obj.tag) { obj = obj.value; }\n    let [p, u, plaintext, signers] = obj;\n    plainObj = cbor.decode(plaintext)\n    \n    if (!rawContents || !plaintext) {\n      return { status: INVALID_SIGNING_FORMAT, raw: rawContents }\n    }\n  } catch (err) {\n    console.log(err)\n    return { status: INVALID_SIGNING_FORMAT, raw: rawContents }\n  }\n\n  const keyID = await getIssuerKeyId(coseContent);\n\n  if (!keyID || !keyID.kid) return { status: KID_NOT_INCLUDED, contents: plainObj, raw: rawContents }\n\n  // Tries B64URL First\n  let issuer = await resolveKey(toBase64(keyID.kid));\n  \n  // if not then use the key passed on the parameter. \n  if (!issuer && addPublicKeyPem) {\n    issuer = { didDocument: addPublicKeyPem, status: \"current\" }\n  }\n\n  if (!issuer) {\n    return { status: ISSUER_NOT_TRUSTED, contents: plainObj, raw: rawContents };\n  }\n\n  let jwk = getJWTFromPEM(issuer.didDocument);\n\n  switch (issuer.status) {\n    case \"revoked\": return    { status: REVOKED_KEYS, contents: plainObj, issuer: issuer, raw: rawContents }\n    case \"terminated\": return { status: TERMINATED_KEYS, contents: plainObj, issuer: issuer, raw: rawContents }\n    case \"expired\": return    { status: EXPIRED_KEYS, contents: plainObj, issuer: issuer, raw: rawContents }\n  }\n\n  try {\n    jwk.kid = toBase64(keyID.kid);\n\n    const verified = await cose.verify(coseContent, { 'jwk': jwk });\n    return { status: VERIFIED, contents: cbor.decode(verified), issuer: issuer, raw: rawContents }\n  } catch (err) {\n     return { status: INVALID_SIGNATURE, contents: plainObj, issuer: issuer, raw: rawContents }\n  }\n}\n\nfunction removePrefix(uri) {\n  let data = uri;\n\n  // Backwards compatibility.\n  if (data.startsWith(URI_SCHEMA)) {\n    data = data.substring(3)\n    if (data.startsWith(':')) {\n      data = data.substring(1)\n    } else {\n      console.warn(\"Warning: unsafe HC1: header from older versions\");\n    };\n  } else {\n      console.warn(\"Warning: no HC1: header from older versions\");\n  };\n  return data;\n}\n\nexport async function unpack(uri) {\n  const data = removePrefix(uri);\n\n  try {\n    let unencodedData = base45.decode(data);\n\n    // Check if it was zipped (Backwards compatibility.)\n    if (unencodedData[0] == 0x78) {\n      unencodedData = zlib.inflate(unencodedData);\n    }\n\n    return unencodedData;\n  } catch (err) {\n    console.log(err)\n    return\n  }\n}\n\nasync function decodeCbor(cborObj) {\n  if (cborObj instanceof Buffer || cborObj instanceof Uint8Array) {\n    try {  \n      cborObj = cbor.decode(cborObj);\n      for (var key in cborObj) {\n        cborObj[key] = await decodeCbor(cborObj[key]);\n      }\n    } catch {\n      cborObj = cborObj.toString('base64');\n    }\n  } \n\n  if (Array.isArray(cborObj)) {\n    for (let i=0; i<cborObj.length; i++) {\n      cborObj[i] = await decodeCbor(cborObj[i])\n    }\n  }\n\n  if (cborObj instanceof Map) {\n    for (const [key, value] of cborObj.entries()) {\n      cborObj.set(key, await decodeCbor(cborObj.get(key)));\n    }\n  }\n\n  return cborObj;\n}\n\nexport async function debug(uri) {\n  return await decodeCbor(await unpack(uri));\n}\n\nexport async function unpackAndVerify(uri, publicKeyPem) {\n  const data = removePrefix(uri);\n\n  try { // Checks if the data is Base45\n    base45.decode(data);\n  } catch (err) {\n    console.log(err)\n    return { status: INVALID_ENCODING, qr: uri };\n  }\n\n  const cbor = await unpack(uri);\n\n  if (!cbor) { \n    return { status: INVALID_COMPRESSION, qr: uri };\n  }\n\n  const verified = await verify(cbor, publicKeyPem);\n  return {...verified, qr: uri} ;\n}\n\nexport async function pack(payload) {\n  const zipped = zlib.deflate(payload);\n  return URI_SCHEMA + ':' + base45.encode(zipped);\n}\n\nexport async function signAndPack(payload, publicKeyPem, privateKeyP8) {\n  return await pack(await sign(payload, publicKeyPem, privateKeyP8));\n}\n\nexport {addCachedCerts, addCachedKeys};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
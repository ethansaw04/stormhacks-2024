{"ast":null,"code":"'use strict';\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\n\nconst Tagged = require('./tagged');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst NoFilter = require('nofilter');\n\nconst stream = require('stream');\n\nconst constants = require('./constants');\n\nconst {\n  MT,\n  NUMBYTES,\n  SYMS,\n  BI\n} = constants;\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst COUNT = Symbol('count');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`);\n    this.name = 'UnexpectedDataError';\n    this.byte = byte;\n    this.value = value;\n  }\n\n}\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\n\n\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb:\n        /** @type {decodeCallback} */\n        opts\n      };\n\n    case 'string':\n      return {\n        options: {\n          encoding:\n          /** @type {BufferEncoding} */\n          opts\n        },\n        cb\n      };\n\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\n\n\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      tags = {},\n      max_depth = -1,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options;\n    super({\n      defaultEncoding: encoding,\n      ...superOpts\n    });\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    this.preferWeb = preferWeb;\n    this.extendedResults = extendedResults;\n    this.required = required;\n    this.preventDuplicateKeys = preventDuplicateKeys;\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this));\n      this.valueBytes =\n      /** @type {NoFilter} */\n      new NoFilter();\n    }\n  }\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n\n\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n\n      case SYMS.UNDEFINED:\n        return undefined;\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n\n      /* istanbul ignore next */\n\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found');\n\n      default:\n        return val;\n    }\n  }\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @static\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   */\n\n\n  static decodeFirstSync(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    ({\n      options\n    } = normalizeOptions(options));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding); // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n\n    const parser = c._parse();\n\n    let state = parser.next();\n\n    while (!state.done) {\n      const b = s.read(state.value);\n\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n\n      if (c.extendedResults) {\n        c.valueBytes.write(b);\n      }\n\n      state = parser.next(b);\n    }\n\n    let val = null;\n\n    if (c.extendedResults) {\n      val = state.value;\n      val.unused = s.read();\n    } else {\n      val = Decoder.nullcheck(state.value);\n\n      if (s.length > 0) {\n        const nextByte = s.read(1);\n        s.unshift(nextByte);\n        throw new UnexpectedDataError(nextByte[0], val);\n      }\n    }\n\n    return val;\n  }\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   */\n\n\n  static decodeAllSync(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    ({\n      options\n    } = normalizeOptions(options));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n    const res = [];\n\n    while (s.length > 0) {\n      const parser = c._parse();\n\n      let state = parser.next();\n\n      while (!state.done) {\n        const b = s.read(state.value);\n\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n\n        if (c.extendedResults) {\n          c.valueBytes.write(b);\n        }\n\n        state = parser.next(b);\n      }\n\n      res.push(Decoder.nullcheck(state.value));\n    }\n\n    return res;\n  }\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   */\n\n\n  static decodeFirst(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const {\n      encoding = 'hex',\n      required = false,\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    let v =\n    /** @type {any} */\n    NOT_FOUND;\n    const s = utils.guessEncoding(input, encoding);\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (c.extendedResults && er instanceof UnexpectedDataError) {\n          v.unused = c.bs.slice();\n          return resolve(v);\n        }\n\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v;\n        }\n\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            }\n\n            return resolve(v);\n          // Pretty sure this can't happen, but not *certain*.\n\n          /* istanbul ignore next */\n\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined;\n\n          default:\n            return resolve(v);\n        }\n      });\n    });\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb);\n    }\n\n    s.pipe(c);\n    return p;\n  }\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   */\n\n\n  static decodeAll(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const c = new Decoder(opts);\n    const vals = [];\n    c.on('data', val => vals.push(Decoder.nullcheck(val)));\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined));\n    }\n\n    utils.guessEncoding(input, encoding).pipe(c);\n    return p;\n  }\n  /**\n   * Stop processing.\n   */\n\n\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n\n\n  _onRead(data) {\n    this.valueBytes.write(data);\n  }\n  /**\n   * @yields {number} Number of bytes to read.\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @ignore\n   */\n\n\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`);\n      }\n\n      const [octet] = yield 1;\n\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]));\n        throw new UnexpectedDataError(octet);\n      }\n\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent == null ? undefined : parent[MAJOR];\n      const parent_length = parent == null ? undefined : parent.length;\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          [val] = yield 1;\n          break;\n\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          {\n            const numbytes = 1 << ai - 24;\n            this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n            const buf = yield numbytes;\n            val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n            break;\n          }\n\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error(`Additional info not implemented: ${ai}`);\n\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n\n          val = -1;\n          break;\n\n        default:\n          val = ai;\n      }\n\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break;\n\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX;\n          } else {\n            val = typeof val === 'bigint' ? BI.MINUS_ONE - val : -1 - val;\n          }\n\n          break;\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n\n              if (mt === MT.UTF8_STRING) {\n                val = '';\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0);\n              }\n\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length);\n              }\n\n          }\n\n          break;\n\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n\n          break;\n\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(`Invalid two-byte encoding of simple value ${val}`);\n            }\n\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n\n      }\n\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1;\n        } else if (Array.isArray(parent)) {\n          parent.push(val);\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR];\n\n          if (pm != null && pm !== mt) {\n            this.running = false;\n            throw new Error('Invalid major type in indefinite encoding');\n          }\n\n          parent.write(val);\n        }\n\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n\n        --depth;\n        delete parent[COUNT];\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n\n            case MT.MAP:\n              {\n                let allstrings = true;\n\n                if (parent.length % 2 !== 0) {\n                  throw new Error(`Invalid map length: ${parent.length}`);\n                }\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (typeof parent[i] !== 'string' || parent[i] === '__proto__') {\n                    allstrings = false;\n                    break;\n                  }\n                }\n\n                if (allstrings) {\n                  val = {};\n\n                  for (let i = 0, len = parent.length; i < len; i += 2) {\n                    if (this.preventDuplicateKeys && Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                      throw new Error('Duplicate keys in a map');\n                    }\n\n                    val[parent[i]] = parent[i + 1];\n                  }\n                } else {\n                  val = new Map();\n\n                  for (let i = 0, len = parent.length; i < len; i += 2) {\n                    if (this.preventDuplicateKeys && val.has(parent[i])) {\n                      throw new Error('Duplicate keys in a map');\n                    }\n\n                    val.set(parent[i], parent[i + 1]);\n                  }\n                }\n\n                break;\n              }\n\n            case MT.TAG:\n              {\n                const t = new Tagged(parent[0], parent[1]);\n                val = t.convert(this.tags);\n                break;\n              }\n          }\n        } else\n          /* istanbul ignore else */\n          if (parent instanceof NoFilter) {\n            // Only parent types are Array and NoFilter for (Array/Map) and\n            // (bytes/string) respectively.\n            switch (parent[MAJOR]) {\n              case MT.BYTE_STRING:\n                val = parent.slice();\n\n                if (this.preferWeb) {\n                  val = new Uint8Array(\n                  /** @type {Buffer} */\n                  val.buffer,\n                  /** @type {Buffer} */\n                  val.byteOffset,\n                  /** @type {Buffer} */\n                  val.length);\n                }\n\n                break;\n\n              case MT.UTF8_STRING:\n                val = parent.toString('utf-8');\n                break;\n            }\n          }\n\n        this.emit('stop', parent[MAJOR]);\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice();\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length\n          };\n          this.valueBytes = new NoFilter();\n          return ret;\n        }\n\n        return val;\n      }\n    }\n  }\n\n}\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":{"version":3,"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/cbor/lib/decoder.js"],"names":["BinaryParseStream","require","Tagged","Simple","utils","NoFilter","stream","constants","MT","NUMBYTES","SYMS","BI","Buffer","COUNT","Symbol","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","a","PARENT","parentBufferStream","b","UnexpectedDataError","Error","constructor","byte","value","toString","name","normalizeOptions","opts","cb","options","encoding","TypeError","Decoder","tags","max_depth","preferWeb","required","extendedResults","preventDuplicateKeys","superOpts","defaultEncoding","running","bs","on","_onRead","bind","valueBytes","nullcheck","val","NULL","UNDEFINED","undefined","decodeFirstSync","input","c","s","guessEncoding","parser","_parse","state","next","done","read","length","write","unused","nextByte","unshift","decodeAllSync","res","push","decodeFirst","v","p","Promise","resolve","reject","close","once","er","slice","then","pipe","decodeAll","vals","__fresh","data","depth","octet","from","mt","ai","parent_major","parent_length","ONE","emit","TWO","FOUR","EIGHT","numbytes","buf","SIMPLE_FLOAT","parseCBORint","INDEFINITE","POS_INT","NEG_INT","TAG","Number","MAX_SAFE_INTEGER","NEG_MAX","MINUS_ONE","BYTE_STRING","UTF8_STRING","Uint8Array","allocUnsafe","STREAM","utf8","buffer","byteOffset","ARRAY","MAP","hasParent","decode","parseCBORfloat","again","BREAK","Array","isArray","pm","allstrings","i","len","Object","prototype","hasOwnProperty","call","Map","has","set","t","convert","old","bytes","ret","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,iBAAiB,GAAGC,OAAO,CAAC,+BAAD,CAAjC;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAM;AAACO,EAAAA,EAAD;AAAKC,EAAAA,QAAL;AAAeC,EAAAA,IAAf;AAAqBC,EAAAA;AAArB,IAA2BJ,SAAjC;;AACA,MAAM;AAACK,EAAAA;AAAD,IAAWX,OAAO,CAAC,QAAD,CAAxB;;AAEA,MAAMY,KAAK,GAAGC,MAAM,CAAC,OAAD,CAApB;AACA,MAAMC,KAAK,GAAGD,MAAM,CAAC,YAAD,CAApB;AACA,MAAME,KAAK,GAAGF,MAAM,CAAC,OAAD,CAApB;AACA,MAAMG,SAAS,GAAGH,MAAM,CAAC,WAAD,CAAxB;;AAEA,SAASI,WAAT,CAAqBC,MAArB,EAA6BC,GAA7B,EAAkCC,KAAlC,EAAyC;AACvC,QAAMC,CAAC,GAAG,EAAV;AAEAA,EAAAA,CAAC,CAACT,KAAD,CAAD,GAAWQ,KAAX;AACAC,EAAAA,CAAC,CAACZ,IAAI,CAACa,MAAN,CAAD,GAAiBJ,MAAjB;AACAG,EAAAA,CAAC,CAACP,KAAD,CAAD,GAAWK,GAAX;AACA,SAAOE,CAAP;AACD;;AAED,SAASE,kBAAT,CAA4BL,MAA5B,EAAoCC,GAApC,EAAyC;AACvC,QAAMK,CAAC,GAAG,IAAIpB,QAAJ,EAAV;AAEAoB,EAAAA,CAAC,CAACZ,KAAD,CAAD,GAAW,CAAC,CAAZ;AACAY,EAAAA,CAAC,CAACf,IAAI,CAACa,MAAN,CAAD,GAAiBJ,MAAjB;AACAM,EAAAA,CAAC,CAACV,KAAD,CAAD,GAAWK,GAAX;AACA,SAAOK,CAAP;AACD;;AAED,MAAMC,mBAAN,SAAkCC,KAAlC,CAAwC;AACtCC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAc;AACvB,UAAO,sBAAqBD,IAAI,CAACE,QAAL,CAAc,EAAd,CAAkB,EAA9C;AACA,SAAKC,IAAL,GAAY,qBAAZ;AACA,SAAKH,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;;AANqC;AASxC;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,gBAAT,CAA0BC,IAA1B,EAAgCC,EAAhC,EAAoC;AAClC,UAAQ,OAAOD,IAAf;AACE,SAAK,UAAL;AACE,aAAO;AAACE,QAAAA,OAAO,EAAE,EAAV;AAAcD,QAAAA,EAAE;AAAE;AAA+BD,QAAAA;AAAjD,OAAP;;AACF,SAAK,QAAL;AACE,aAAO;AAACE,QAAAA,OAAO,EAAE;AAACC,UAAAA,QAAQ;AAAE;AAA+BH,UAAAA;AAA1C,SAAV;AAA4DC,QAAAA;AAA5D,OAAP;;AACF,SAAK,QAAL;AACE,aAAO;AAACC,QAAAA,OAAO,EAAEF,IAAI,IAAI,EAAlB;AAAsBC,QAAAA;AAAtB,OAAP;;AACF;AACE,YAAM,IAAIG,SAAJ,CAAc,qBAAd,CAAN;AARJ;AAUD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,OAAN,SAAsBvC,iBAAtB,CAAwC;AACtC;AACF;AACA;AACA;AACA;AACE4B,EAAAA,WAAW,GAAe;AAAA,QAAdQ,OAAc,uEAAJ,EAAI;AACxB,UAAM;AACJI,MAAAA,IAAI,GAAG,EADH;AAEJC,MAAAA,SAAS,GAAG,CAAC,CAFT;AAGJC,MAAAA,SAAS,GAAG,KAHR;AAIJC,MAAAA,QAAQ,GAAG,KAJP;AAKJN,MAAAA,QAAQ,GAAG,KALP;AAMJO,MAAAA,eAAe,GAAG,KANd;AAOJC,MAAAA,oBAAoB,GAAG,KAPnB;AAQJ,SAAGC;AARC,QASFV,OATJ;AAWA,UAAM;AAACW,MAAAA,eAAe,EAAEV,QAAlB;AAA4B,SAAGS;AAA/B,KAAN;AAEA,SAAKE,OAAL,GAAe,IAAf;AACA,SAAKP,SAAL,GAAiBA,SAAjB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKE,SAAL,GAAiBA,SAAjB;AACA,SAAKE,eAAL,GAAuBA,eAAvB;AACA,SAAKD,QAAL,GAAgBA,QAAhB;AACA,SAAKE,oBAAL,GAA4BA,oBAA5B;;AAEA,QAAID,eAAJ,EAAqB;AACnB,WAAKK,EAAL,CAAQC,EAAR,CAAW,MAAX,EAAmB,KAAKC,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAAnB;AACA,WAAKC,UAAL;AAAkB;AAAyB,UAAIhD,QAAJ,EAA3C;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,SAATiD,SAAS,CAACC,GAAD,EAAM;AACpB,YAAQA,GAAR;AACE,WAAK7C,IAAI,CAAC8C,IAAV;AACE,eAAO,IAAP;;AACF,WAAK9C,IAAI,CAAC+C,SAAV;AACE,eAAOC,SAAP;AACF;AACA;;AACA;;AACA,WAAKzC,SAAL;AACE;AACA,cAAM,IAAIU,KAAJ,CAAU,iBAAV,CAAN;;AACF;AACE,eAAO4B,GAAP;AAZJ;AAcD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,SAAfI,eAAe,CAACC,KAAD,EAAsB;AAAA,QAAdxB,OAAc,uEAAJ,EAAI;;AAC1C,QAAIwB,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAM,IAAItB,SAAJ,CAAc,gBAAd,CAAN;AACD;;AACD,KAAC;AAACF,MAAAA;AAAD,QAAYH,gBAAgB,CAACG,OAAD,CAA7B;AACA,UAAM;AAACC,MAAAA,QAAQ,GAAG,KAAZ;AAAmB,SAAGH;AAAtB,QAA8BE,OAApC;AACA,UAAMyB,CAAC,GAAG,IAAItB,OAAJ,CAAYL,IAAZ,CAAV;AACA,UAAM4B,CAAC,GAAG1D,KAAK,CAAC2D,aAAN,CAAoBH,KAApB,EAA2BvB,QAA3B,CAAV,CAP0C,CAS1C;AACA;AACA;;AACA,UAAM2B,MAAM,GAAGH,CAAC,CAACI,MAAF,EAAf;;AACA,QAAIC,KAAK,GAAGF,MAAM,CAACG,IAAP,EAAZ;;AAEA,WAAO,CAACD,KAAK,CAACE,IAAd,EAAoB;AAClB,YAAM3C,CAAC,GAAGqC,CAAC,CAACO,IAAF,CAAOH,KAAK,CAACpC,KAAb,CAAV;;AAEA,UAAKL,CAAC,IAAI,IAAN,IAAgBA,CAAC,CAAC6C,MAAF,KAAaJ,KAAK,CAACpC,KAAvC,EAA+C;AAC7C,cAAM,IAAIH,KAAJ,CAAU,mBAAV,CAAN;AACD;;AACD,UAAIkC,CAAC,CAACjB,eAAN,EAAuB;AACrBiB,QAAAA,CAAC,CAACR,UAAF,CAAakB,KAAb,CAAmB9C,CAAnB;AACD;;AACDyC,MAAAA,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY1C,CAAZ,CAAR;AACD;;AAED,QAAI8B,GAAG,GAAG,IAAV;;AACA,QAAIM,CAAC,CAACjB,eAAN,EAAuB;AACrBW,MAAAA,GAAG,GAAGW,KAAK,CAACpC,KAAZ;AACAyB,MAAAA,GAAG,CAACiB,MAAJ,GAAaV,CAAC,CAACO,IAAF,EAAb;AACD,KAHD,MAGO;AACLd,MAAAA,GAAG,GAAGhB,OAAO,CAACe,SAAR,CAAkBY,KAAK,CAACpC,KAAxB,CAAN;;AACA,UAAIgC,CAAC,CAACQ,MAAF,GAAW,CAAf,EAAkB;AAChB,cAAMG,QAAQ,GAAGX,CAAC,CAACO,IAAF,CAAO,CAAP,CAAjB;AAEAP,QAAAA,CAAC,CAACY,OAAF,CAAUD,QAAV;AACA,cAAM,IAAI/C,mBAAJ,CAAwB+C,QAAQ,CAAC,CAAD,CAAhC,EAAqClB,GAArC,CAAN;AACD;AACF;;AACD,WAAOA,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACsB,SAAboB,aAAa,CAACf,KAAD,EAAsB;AAAA,QAAdxB,OAAc,uEAAJ,EAAI;;AACxC,QAAIwB,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAM,IAAItB,SAAJ,CAAc,gBAAd,CAAN;AACD;;AACD,KAAC;AAACF,MAAAA;AAAD,QAAYH,gBAAgB,CAACG,OAAD,CAA7B;AACA,UAAM;AAACC,MAAAA,QAAQ,GAAG,KAAZ;AAAmB,SAAGH;AAAtB,QAA8BE,OAApC;AACA,UAAMyB,CAAC,GAAG,IAAItB,OAAJ,CAAYL,IAAZ,CAAV;AACA,UAAM4B,CAAC,GAAG1D,KAAK,CAAC2D,aAAN,CAAoBH,KAApB,EAA2BvB,QAA3B,CAAV;AACA,UAAMuC,GAAG,GAAG,EAAZ;;AAEA,WAAOd,CAAC,CAACQ,MAAF,GAAW,CAAlB,EAAqB;AACnB,YAAMN,MAAM,GAAGH,CAAC,CAACI,MAAF,EAAf;;AACA,UAAIC,KAAK,GAAGF,MAAM,CAACG,IAAP,EAAZ;;AAEA,aAAO,CAACD,KAAK,CAACE,IAAd,EAAoB;AAClB,cAAM3C,CAAC,GAAGqC,CAAC,CAACO,IAAF,CAAOH,KAAK,CAACpC,KAAb,CAAV;;AAEA,YAAKL,CAAC,IAAI,IAAN,IAAgBA,CAAC,CAAC6C,MAAF,KAAaJ,KAAK,CAACpC,KAAvC,EAA+C;AAC7C,gBAAM,IAAIH,KAAJ,CAAU,mBAAV,CAAN;AACD;;AACD,YAAIkC,CAAC,CAACjB,eAAN,EAAuB;AACrBiB,UAAAA,CAAC,CAACR,UAAF,CAAakB,KAAb,CAAmB9C,CAAnB;AACD;;AACDyC,QAAAA,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY1C,CAAZ,CAAR;AACD;;AACDmD,MAAAA,GAAG,CAACC,IAAJ,CAAStC,OAAO,CAACe,SAAR,CAAkBY,KAAK,CAACpC,KAAxB,CAAT;AACD;;AACD,WAAO8C,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoB,SAAXE,WAAW,CAAClB,KAAD,EAAiC;AAAA,QAAzBxB,OAAyB,uEAAf,EAAe;AAAA,QAAXD,EAAW,uEAAN,IAAM;;AACjD,QAAIyB,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAM,IAAItB,SAAJ,CAAc,gBAAd,CAAN;AACD;;AACD,KAAC;AAACF,MAAAA,OAAD;AAAUD,MAAAA;AAAV,QAAgBF,gBAAgB,CAACG,OAAD,EAAUD,EAAV,CAAjC;AACA,UAAM;AAACE,MAAAA,QAAQ,GAAG,KAAZ;AAAmBM,MAAAA,QAAQ,GAAG,KAA9B;AAAqC,SAAGT;AAAxC,QAAgDE,OAAtD;AAEA,UAAMyB,CAAC,GAAG,IAAItB,OAAJ,CAAYL,IAAZ,CAAV;AACA,QAAI6C,CAAC;AAAG;AAAoB9D,IAAAA,SAA5B;AACA,UAAM6C,CAAC,GAAG1D,KAAK,CAAC2D,aAAN,CAAoBH,KAApB,EAA2BvB,QAA3B,CAAV;AACA,UAAM2C,CAAC,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACzCtB,MAAAA,CAAC,CAACX,EAAF,CAAK,MAAL,EAAaK,GAAG,IAAI;AAClBwB,QAAAA,CAAC,GAAGxC,OAAO,CAACe,SAAR,CAAkBC,GAAlB,CAAJ;AACAM,QAAAA,CAAC,CAACuB,KAAF;AACD,OAHD;AAIAvB,MAAAA,CAAC,CAACwB,IAAF,CAAO,OAAP,EAAgBC,EAAE,IAAI;AACpB,YAAIzB,CAAC,CAACjB,eAAF,IAAsB0C,EAAE,YAAY5D,mBAAxC,EAA8D;AAC5DqD,UAAAA,CAAC,CAACP,MAAF,GAAWX,CAAC,CAACZ,EAAF,CAAKsC,KAAL,EAAX;AACA,iBAAOL,OAAO,CAACH,CAAD,CAAd;AACD;;AACD,YAAIA,CAAC,KAAK9D,SAAV,EAAqB;AACnB;AACA;AACAqE,UAAAA,EAAE,CAAC,OAAD,CAAF,GAAcP,CAAd;AACD;;AACDA,QAAAA,CAAC,GAAG/D,KAAJ;AACA6C,QAAAA,CAAC,CAACuB,KAAF;AACA,eAAOD,MAAM,CAACG,EAAD,CAAb;AACD,OAbD;AAcAzB,MAAAA,CAAC,CAACwB,IAAF,CAAO,KAAP,EAAc,MAAM;AAClB,gBAAQN,CAAR;AACE,eAAK9D,SAAL;AACE,gBAAI0B,QAAJ,EAAc;AACZ,qBAAOwC,MAAM,CAAC,IAAIxD,KAAJ,CAAU,eAAV,CAAD,CAAb;AACD;;AACD,mBAAOuD,OAAO,CAACH,CAAD,CAAd;AACF;;AACA;;AACA,eAAK/D,KAAL;AACE;AACA,mBAAO0C,SAAP;;AACF;AACE,mBAAOwB,OAAO,CAACH,CAAD,CAAd;AAZJ;AAcD,OAfD;AAgBD,KAnCS,CAAV;;AAqCA,QAAI,OAAO5C,EAAP,KAAc,UAAlB,EAA8B;AAC5B6C,MAAAA,CAAC,CAACQ,IAAF,CAAOjC,GAAG,IAAIpB,EAAE,CAAC,IAAD,EAAOoB,GAAP,CAAhB,EAA6BpB,EAA7B;AACD;;AACD2B,IAAAA,CAAC,CAAC2B,IAAF,CAAO5B,CAAP;AACA,WAAOmB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,SAATU,SAAS,CAAC9B,KAAD,EAAiC;AAAA,QAAzBxB,OAAyB,uEAAf,EAAe;AAAA,QAAXD,EAAW,uEAAN,IAAM;;AAC/C,QAAIyB,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAM,IAAItB,SAAJ,CAAc,gBAAd,CAAN;AACD;;AACD,KAAC;AAACF,MAAAA,OAAD;AAAUD,MAAAA;AAAV,QAAgBF,gBAAgB,CAACG,OAAD,EAAUD,EAAV,CAAjC;AACA,UAAM;AAACE,MAAAA,QAAQ,GAAG,KAAZ;AAAmB,SAAGH;AAAtB,QAA8BE,OAApC;AAEA,UAAMyB,CAAC,GAAG,IAAItB,OAAJ,CAAYL,IAAZ,CAAV;AACA,UAAMyD,IAAI,GAAG,EAAb;AAEA9B,IAAAA,CAAC,CAACX,EAAF,CAAK,MAAL,EAAaK,GAAG,IAAIoC,IAAI,CAACd,IAAL,CAAUtC,OAAO,CAACe,SAAR,CAAkBC,GAAlB,CAAV,CAApB;AAEA,UAAMyB,CAAC,GAAG,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACzCtB,MAAAA,CAAC,CAACX,EAAF,CAAK,OAAL,EAAciC,MAAd;AACAtB,MAAAA,CAAC,CAACX,EAAF,CAAK,KAAL,EAAY,MAAMgC,OAAO,CAACS,IAAD,CAAzB;AACD,KAHS,CAAV;;AAKA,QAAI,OAAOxD,EAAP,KAAc,UAAlB,EAA8B;AAC5B6C,MAAAA,CAAC,CAACQ,IAAF,CAAOT,CAAC,IAAI5C,EAAE,CAACuB,SAAD,EAAYqB,CAAZ,CAAd,EAA8BO,EAAE,IAAInD,EAAE,CAACmD,EAAD,EAAK5B,SAAL,CAAtC;AACD;;AACDtD,IAAAA,KAAK,CAAC2D,aAAN,CAAoBH,KAApB,EAA2BvB,QAA3B,EAAqCoD,IAArC,CAA0C5B,CAA1C;AACA,WAAOmB,CAAP;AACD;AAED;AACF;AACA;;;AACEI,EAAAA,KAAK,GAAG;AACN,SAAKpC,OAAL,GAAe,KAAf;AACA,SAAK4C,OAAL,GAAe,IAAf;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEzC,EAAAA,OAAO,CAAC0C,IAAD,EAAO;AACZ,SAAKxC,UAAL,CAAgBkB,KAAhB,CAAsBsB,IAAtB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACS,GAAN5B,MAAM,GAAG;AACR,QAAI9C,MAAM,GAAG,IAAb;AACA,QAAI2E,KAAK,GAAG,CAAZ;AACA,QAAIvC,GAAG,GAAG,IAAV;;AAEA,WAAO,IAAP,EAAa;AACX,UAAK,KAAKd,SAAL,IAAkB,CAAnB,IAA0BqD,KAAK,GAAG,KAAKrD,SAA3C,EAAuD;AACrD,cAAM,IAAId,KAAJ,CAAW,iBAAgB,KAAKc,SAAU,WAA1C,CAAN;AACD;;AAED,YAAM,CAACsD,KAAD,IAAU,MAAM,CAAtB;;AACA,UAAI,CAAC,KAAK/C,OAAV,EAAmB;AACjB,aAAKC,EAAL,CAAQyB,OAAR,CAAgB9D,MAAM,CAACoF,IAAP,CAAY,CAACD,KAAD,CAAZ,CAAhB;AACA,cAAM,IAAIrE,mBAAJ,CAAwBqE,KAAxB,CAAN;AACD;;AACD,YAAME,EAAE,GAAGF,KAAK,IAAI,CAApB;AACA,YAAMG,EAAE,GAAGH,KAAK,GAAG,IAAnB;AACA,YAAMI,YAAY,GAAIhF,MAAM,IAAI,IAAX,GAAmBuC,SAAnB,GAA+BvC,MAAM,CAACJ,KAAD,CAA1D;AACA,YAAMqF,aAAa,GAAIjF,MAAM,IAAI,IAAX,GAAmBuC,SAAnB,GAA+BvC,MAAM,CAACmD,MAA5D;;AAEA,cAAQ4B,EAAR;AACE,aAAKzF,QAAQ,CAAC4F,GAAd;AACE,eAAKC,IAAL,CAAU,YAAV,EAAwBL,EAAxB,EAA4B,CAA5B,EAA+BE,YAA/B,EAA6CC,aAA7C;AACC,WAAC7C,GAAD,IAAQ,MAAM,CAAd;AACD;;AACF,aAAK9C,QAAQ,CAAC8F,GAAd;AACA,aAAK9F,QAAQ,CAAC+F,IAAd;AACA,aAAK/F,QAAQ,CAACgG,KAAd;AAAqB;AACnB,kBAAMC,QAAQ,GAAG,KAAMR,EAAE,GAAG,EAA5B;AAEA,iBAAKI,IAAL,CAAU,YAAV,EAAwBL,EAAxB,EAA4BS,QAA5B,EAAsCP,YAAtC,EAAoDC,aAApD;AACA,kBAAMO,GAAG,GAAG,MAAMD,QAAlB;AACAnD,YAAAA,GAAG,GAAI0C,EAAE,KAAKzF,EAAE,CAACoG,YAAX,GACJD,GADI,GAEJvG,KAAK,CAACyG,YAAN,CAAmBX,EAAnB,EAAuBS,GAAvB,CAFF;AAGA;AACD;;AACD,aAAK,EAAL;AACA,aAAK,EAAL;AACA,aAAK,EAAL;AACE,eAAK3D,OAAL,GAAe,KAAf;AACA,gBAAM,IAAIrB,KAAJ,CAAW,oCAAmCuE,EAAG,EAAjD,CAAN;;AACF,aAAKzF,QAAQ,CAACqG,UAAd;AACE,kBAAQb,EAAR;AACE,iBAAKzF,EAAE,CAACuG,OAAR;AACA,iBAAKvG,EAAE,CAACwG,OAAR;AACA,iBAAKxG,EAAE,CAACyG,GAAR;AACE,oBAAM,IAAItF,KAAJ,CAAW,sCAAqCsE,EAAG,EAAnD,CAAN;AAJJ;;AAMA1C,UAAAA,GAAG,GAAG,CAAC,CAAP;AACA;;AACF;AACEA,UAAAA,GAAG,GAAG2C,EAAN;AAhCJ;;AAkCA,cAAQD,EAAR;AACE,aAAKzF,EAAE,CAACuG,OAAR;AACE;AACA;;AACF,aAAKvG,EAAE,CAACwG,OAAR;AACE,cAAIzD,GAAG,KAAK2D,MAAM,CAACC,gBAAnB,EAAqC;AACnC5D,YAAAA,GAAG,GAAG5C,EAAE,CAACyG,OAAT;AACD,WAFD,MAEO;AACL7D,YAAAA,GAAG,GAAI,OAAOA,GAAP,KAAe,QAAhB,GAA4B5C,EAAE,CAAC0G,SAAH,GAAe9D,GAA3C,GAAiD,CAAC,CAAD,GAAKA,GAA5D;AACD;;AACD;;AACF,aAAK/C,EAAE,CAAC8G,WAAR;AACA,aAAK9G,EAAE,CAAC+G,WAAR;AACE,kBAAQhE,GAAR;AACE,iBAAK,CAAL;AACE,mBAAK+C,IAAL,CAAU,cAAV,EAA0BL,EAA1B,EAA8B1C,GAA9B,EAAmC4C,YAAnC,EAAiDC,aAAjD;;AACA,kBAAIH,EAAE,KAAKzF,EAAE,CAAC+G,WAAd,EAA2B;AACzBhE,gBAAAA,GAAG,GAAG,EAAN;AACD,eAFD,MAEO;AACLA,gBAAAA,GAAG,GAAG,KAAKb,SAAL,GAAiB,IAAI8E,UAAJ,CAAe,CAAf,CAAjB,GAAqC5G,MAAM,CAAC6G,WAAP,CAAmB,CAAnB,CAA3C;AACD;;AACD;;AACF,iBAAK,CAAC,CAAN;AACE,mBAAKnB,IAAL,CAAU,OAAV,EAAmBL,EAAnB,EAAuBvF,IAAI,CAACgH,MAA5B,EAAoCvB,YAApC,EAAkDC,aAAlD;AACAjF,cAAAA,MAAM,GAAGK,kBAAkB,CAACL,MAAD,EAAS8E,EAAT,CAA3B;AACAH,cAAAA,KAAK;AACL;;AACF;AACE,mBAAKQ,IAAL,CAAU,cAAV,EAA0BL,EAA1B,EAA8B1C,GAA9B,EAAmC4C,YAAnC,EAAiDC,aAAjD;AACA7C,cAAAA,GAAG,GAAG,MAAMA,GAAZ;;AACA,kBAAI0C,EAAE,KAAKzF,EAAE,CAAC+G,WAAd,EAA2B;AACzBhE,gBAAAA,GAAG,GAAGnD,KAAK,CAACuH,IAAN,CAAWpE,GAAX,CAAN;AACD,eAFD,MAEO,IAAI,KAAKb,SAAT,EAAoB;AACzBa,gBAAAA,GAAG,GAAG,IAAIiE,UAAJ,CAAejE,GAAG,CAACqE,MAAnB,EAA2BrE,GAAG,CAACsE,UAA/B,EAA2CtE,GAAG,CAACe,MAA/C,CAAN;AACD;;AArBL;;AAuBA;;AACF,aAAK9D,EAAE,CAACsH,KAAR;AACA,aAAKtH,EAAE,CAACuH,GAAR;AACE,kBAAQxE,GAAR;AACE,iBAAK,CAAL;AACEA,cAAAA,GAAG,GAAI0C,EAAE,KAAKzF,EAAE,CAACuH,GAAX,GAAkB,EAAlB,GAAuB,EAA7B;AACA;;AACF,iBAAK,CAAC,CAAN;AACE,mBAAKzB,IAAL,CAAU,OAAV,EAAmBL,EAAnB,EAAuBvF,IAAI,CAACgH,MAA5B,EAAoCvB,YAApC,EAAkDC,aAAlD;AACAjF,cAAAA,MAAM,GAAGD,WAAW,CAACC,MAAD,EAAS8E,EAAT,EAAa,CAAC,CAAd,CAApB;AACAH,cAAAA,KAAK;AACL;;AACF;AACE,mBAAKQ,IAAL,CAAU,OAAV,EAAmBL,EAAnB,EAAuB1C,GAAvB,EAA4B4C,YAA5B,EAA0CC,aAA1C;AACAjF,cAAAA,MAAM,GAAGD,WAAW,CAACC,MAAD,EAAS8E,EAAT,EAAa1C,GAAG,IAAI0C,EAAE,GAAG,CAAT,CAAhB,CAApB;AACAH,cAAAA,KAAK;AACL;AAbJ;;AAeA;;AACF,aAAKtF,EAAE,CAACyG,GAAR;AACE,eAAKX,IAAL,CAAU,OAAV,EAAmBL,EAAnB,EAAuB1C,GAAvB,EAA4B4C,YAA5B,EAA0CC,aAA1C;AACAjF,UAAAA,MAAM,GAAGD,WAAW,CAACC,MAAD,EAAS8E,EAAT,EAAa,CAAb,CAApB;AACA9E,UAAAA,MAAM,CAAC0D,IAAP,CAAYtB,GAAZ;AACAuC,UAAAA,KAAK;AACL;;AACF,aAAKtF,EAAE,CAACoG,YAAR;AACE,cAAI,OAAOrD,GAAP,KAAe,QAAnB,EAA6B;AAC3B,gBAAK2C,EAAE,KAAKzF,QAAQ,CAAC4F,GAAjB,IAA0B9C,GAAG,GAAG,EAApC,EAAyC;AACvC,oBAAM,IAAI5B,KAAJ,CACH,6CAA4C4B,GAAI,EAD7C,CAAN;AAGD;;AACD,kBAAMyE,SAAS,GAAI7G,MAAM,IAAI,IAA7B;AACAoC,YAAAA,GAAG,GAAGpD,MAAM,CAAC8H,MAAP,CACJ1E,GADI,EAEJyE,SAFI,EAGJA,SAAS,IAAK7G,MAAM,CAACN,KAAD,CAAN,GAAgB,CAH1B,CAAN;AAKD,WAZD,MAYO;AACL0C,YAAAA,GAAG,GAAGnD,KAAK,CAAC8H,cAAN,CAAqB3E,GAArB,CAAN;AACD;;AA5EL;;AA8EA,WAAK+C,IAAL,CAAU,OAAV,EAAmB/C,GAAnB,EAAwB4C,YAAxB,EAAsCC,aAAtC,EAAqDF,EAArD;AACA,UAAIiC,KAAK,GAAG,KAAZ;;AACA,aAAOhH,MAAM,IAAI,IAAjB,EAAuB;AACrB,YAAIoC,GAAG,KAAK7C,IAAI,CAAC0H,KAAjB,EAAwB;AACtBjH,UAAAA,MAAM,CAACN,KAAD,CAAN,GAAgB,CAAhB;AACD,SAFD,MAEO,IAAIwH,KAAK,CAACC,OAAN,CAAcnH,MAAd,CAAJ,EAA2B;AAChCA,UAAAA,MAAM,CAAC0D,IAAP,CAAYtB,GAAZ;AACD,SAFM,MAEA;AACL;AACA,gBAAMgF,EAAE,GAAGpH,MAAM,CAACJ,KAAD,CAAjB;;AAEA,cAAKwH,EAAE,IAAI,IAAP,IAAiBA,EAAE,KAAKtC,EAA5B,EAAiC;AAC/B,iBAAKjD,OAAL,GAAe,KAAf;AACA,kBAAM,IAAIrB,KAAJ,CAAU,2CAAV,CAAN;AACD;;AACDR,UAAAA,MAAM,CAACoD,KAAP,CAAahB,GAAb;AACD;;AAED,YAAK,EAAEpC,MAAM,CAACN,KAAD,CAAT,KAAsB,CAA1B,EAA6B;AAC3BsH,UAAAA,KAAK,GAAG,IAAR;AACA;AACD;;AACD,UAAErC,KAAF;AACA,eAAO3E,MAAM,CAACN,KAAD,CAAb;;AAEA,YAAIwH,KAAK,CAACC,OAAN,CAAcnH,MAAd,CAAJ,EAA2B;AACzB,kBAAQA,MAAM,CAACJ,KAAD,CAAd;AACE,iBAAKP,EAAE,CAACsH,KAAR;AACEvE,cAAAA,GAAG,GAAGpC,MAAN;AACA;;AACF,iBAAKX,EAAE,CAACuH,GAAR;AAAa;AACX,oBAAIS,UAAU,GAAG,IAAjB;;AAEA,oBAAKrH,MAAM,CAACmD,MAAP,GAAgB,CAAjB,KAAwB,CAA5B,EAA+B;AAC7B,wBAAM,IAAI3C,KAAJ,CAAW,uBAAsBR,MAAM,CAACmD,MAAO,EAA/C,CAAN;AACD;;AACD,qBAAK,IAAImE,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvH,MAAM,CAACmD,MAA7B,EAAqCmE,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,IAAI,CAAnD,EAAsD;AACpD,sBAAK,OAAOtH,MAAM,CAACsH,CAAD,CAAb,KAAqB,QAAtB,IACCtH,MAAM,CAACsH,CAAD,CAAN,KAAc,WADnB,EACiC;AAC/BD,oBAAAA,UAAU,GAAG,KAAb;AACA;AACD;AACF;;AACD,oBAAIA,UAAJ,EAAgB;AACdjF,kBAAAA,GAAG,GAAG,EAAN;;AACA,uBAAK,IAAIkF,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvH,MAAM,CAACmD,MAA7B,EAAqCmE,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,IAAI,CAAnD,EAAsD;AACpD,wBAAI,KAAK5F,oBAAL,IACF8F,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCvF,GAArC,EAA0CpC,MAAM,CAACsH,CAAD,CAAhD,CADF,EACwD;AACtD,4BAAM,IAAI9G,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD4B,oBAAAA,GAAG,CAACpC,MAAM,CAACsH,CAAD,CAAP,CAAH,GAAiBtH,MAAM,CAACsH,CAAC,GAAG,CAAL,CAAvB;AACD;AACF,iBATD,MASO;AACLlF,kBAAAA,GAAG,GAAG,IAAIwF,GAAJ,EAAN;;AACA,uBAAK,IAAIN,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvH,MAAM,CAACmD,MAA7B,EAAqCmE,CAAC,GAAGC,GAAzC,EAA8CD,CAAC,IAAI,CAAnD,EAAsD;AACpD,wBAAI,KAAK5F,oBAAL,IAA6BU,GAAG,CAACyF,GAAJ,CAAQ7H,MAAM,CAACsH,CAAD,CAAd,CAAjC,EAAqD;AACnD,4BAAM,IAAI9G,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD4B,oBAAAA,GAAG,CAAC0F,GAAJ,CAAQ9H,MAAM,CAACsH,CAAD,CAAd,EAAmBtH,MAAM,CAACsH,CAAC,GAAG,CAAL,CAAzB;AACD;AACF;;AACD;AACD;;AACD,iBAAKjI,EAAE,CAACyG,GAAR;AAAa;AACX,sBAAMiC,CAAC,GAAG,IAAIhJ,MAAJ,CAAWiB,MAAM,CAAC,CAAD,CAAjB,EAAsBA,MAAM,CAAC,CAAD,CAA5B,CAAV;AAEAoC,gBAAAA,GAAG,GAAG2F,CAAC,CAACC,OAAF,CAAU,KAAK3G,IAAf,CAAN;AACA;AACD;AA1CH;AA4CD,SA7CD;AA6CO;AAA2B,cAAIrB,MAAM,YAAYd,QAAtB,EAAgC;AAChE;AACA;AACA,oBAAQc,MAAM,CAACJ,KAAD,CAAd;AACE,mBAAKP,EAAE,CAAC8G,WAAR;AACE/D,gBAAAA,GAAG,GAAGpC,MAAM,CAACoE,KAAP,EAAN;;AACA,oBAAI,KAAK7C,SAAT,EAAoB;AAClBa,kBAAAA,GAAG,GAAG,IAAIiE,UAAJ;AACJ;AAAuBjE,kBAAAA,GAAD,CAAMqE,MADxB;AAEJ;AAAuBrE,kBAAAA,GAAD,CAAMsE,UAFxB;AAGJ;AAAuBtE,kBAAAA,GAAD,CAAMe,MAHxB,CAAN;AAKD;;AACD;;AACF,mBAAK9D,EAAE,CAAC+G,WAAR;AACEhE,gBAAAA,GAAG,GAAGpC,MAAM,CAACY,QAAP,CAAgB,OAAhB,CAAN;AACA;AAbJ;AAeD;;AACD,aAAKuE,IAAL,CAAU,MAAV,EAAkBnF,MAAM,CAACJ,KAAD,CAAxB;AAEA,cAAMqI,GAAG,GAAGjI,MAAZ;AACAA,QAAAA,MAAM,GAAGA,MAAM,CAACT,IAAI,CAACa,MAAN,CAAf;AACA,eAAO6H,GAAG,CAAC1I,IAAI,CAACa,MAAN,CAAV;AACA,eAAO6H,GAAG,CAACrI,KAAD,CAAV;AACD;;AACD,UAAI,CAACoH,KAAL,EAAY;AACV,YAAI,KAAKvF,eAAT,EAA0B;AACxB,gBAAMyG,KAAK,GAAG,KAAKhG,UAAL,CAAgBkC,KAAhB,EAAd;AACA,gBAAM+D,GAAG,GAAG;AACVxH,YAAAA,KAAK,EAAES,OAAO,CAACe,SAAR,CAAkBC,GAAlB,CADG;AAEV8F,YAAAA,KAFU;AAGV/E,YAAAA,MAAM,EAAE+E,KAAK,CAAC/E;AAHJ,WAAZ;AAMA,eAAKjB,UAAL,GAAkB,IAAIhD,QAAJ,EAAlB;AACA,iBAAOiJ,GAAP;AACD;;AACD,eAAO/F,GAAP;AACD;AACF;AACF;;AAliBqC;;AAqiBxChB,OAAO,CAACtB,SAAR,GAAoBA,SAApB;AACAsI,MAAM,CAACC,OAAP,GAAiBjH,OAAjB","sourcesContent":["'use strict'\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {MT, NUMBYTES, SYMS, BI} = constants\nconst {Buffer} = require('buffer')\n\nconst COUNT = Symbol('count')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`)\n    this.name = 'UnexpectedDataError'\n    this.byte = byte\n    this.value = value\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options\n\n    super({defaultEncoding: encoding, ...superOpts})\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    this.preferWeb = preferWeb\n    this.extendedResults = extendedResults\n    this.required = required\n    this.preventDuplicateKeys = preventDuplicateKeys\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this))\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter())\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @static\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n\n    while (!state.done) {\n      const b = s.read(state.value)\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b)\n      }\n      state = parser.next(b)\n    }\n\n    let val = null\n    if (c.extendedResults) {\n      val = state.value\n      val.unused = s.read()\n    } else {\n      val = Decoder.nullcheck(state.value)\n      if (s.length > 0) {\n        const nextByte = s.read(1)\n\n        s.unshift(nextByte)\n        throw new UnexpectedDataError(nextByte[0], val)\n      }\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n    const res = []\n\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n\n      while (!state.done) {\n        const b = s.read(state.value)\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b)\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', required = false, ...opts} = options\n\n    const c = new Decoder(opts)\n    let v = /** @type {any} */ (NOT_FOUND)\n    const s = utils.guessEncoding(input, encoding)\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice()\n          return resolve(v)\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            }\n            return resolve(v)\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb)\n    }\n    s.pipe(c)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const c = new Decoder(opts)\n    const vals = []\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)))\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined))\n    }\n    utils.guessEncoding(input, encoding).pipe(c)\n    return p\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data)\n  }\n\n  /**\n   * @yields {number} Number of bytes to read.\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`)\n      }\n\n      const [octet] = yield 1\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]))\n        throw new UnexpectedDataError(octet)\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent == null) ? undefined : parent[MAJOR]\n      const parent_length = (parent == null) ? undefined : parent.length\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          ;[val] = yield 1\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24)\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf)\n          break\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error(`Additional info not implemented: ${ai}`)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              if (mt === MT.UTF8_STRING) {\n                val = ''\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0)\n              }\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            )\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1\n        } else if (Array.isArray(parent)) {\n          parent.push(val)\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR]\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false\n            throw new Error('Invalid major type in indefinite encoding')\n          }\n          parent.write(val)\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP: {\n              let allstrings = true\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map()\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1])\n\n              val = t.convert(this.tags)\n              break\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                )\n              }\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice()\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          }\n\n          this.valueBytes = new NoFilter()\n          return ret\n        }\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n'use strict';\n\nconst stream = require('stream');\n\nconst NoFilter = require('nofilter');\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\n\n\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @param {stream.TransformOptions} options Stream options.\n   * @memberof BinaryParseStream\n   */\n  constructor(options) {\n    super(options); // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n\n    this['_writableState'].objectMode = false; // eslint-disable-next-line dot-notation\n\n    this['_readableState'].objectMode = true;\n    this.bs = new NoFilter();\n\n    this.__restart();\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh);\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null;\n      const chunk = this.__needed === null ? undefined : this.bs.read(this.__needed);\n\n      try {\n        ret = this.__parser.next(chunk);\n      } catch (e) {\n        return cb(e);\n      }\n\n      if (this.__needed) {\n        this.__fresh = false;\n      }\n\n      if (ret.done) {\n        this.push(ret.value);\n\n        this.__restart();\n      } else {\n        this.__needed = ret.value || Infinity;\n      }\n    }\n\n    return cb();\n  }\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, undefined, Buffer>}\n   */\n\n  /* istanbul ignore next */\n\n\n  *_parse() {\n    // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass');\n  }\n\n  __restart() {\n    this.__needed = null;\n    this.__parser = this._parse();\n    this.__fresh = true;\n  }\n\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'));\n  }\n\n}\n\nmodule.exports = BinaryParseStream;","map":{"version":3,"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/cbor/vendor/binary-parse-stream/index.js"],"names":["stream","require","NoFilter","BinaryParseStream","Transform","constructor","options","objectMode","bs","__restart","_transform","fresh","encoding","cb","write","length","__needed","ret","chunk","undefined","read","__parser","next","e","__fresh","done","push","value","Infinity","_parse","Error","_flush","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,iBAAN,SAAgCH,MAAM,CAACI,SAAvC,CAAiD;AAC/C;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMA,OAAN,EADmB,CAEnB;AACA;AACA;;AACA,SAAK,gBAAL,EAAuBC,UAAvB,GAAoC,KAApC,CALmB,CAMnB;;AACA,SAAK,gBAAL,EAAuBA,UAAvB,GAAoC,IAApC;AAEA,SAAKC,EAAL,GAAU,IAAIN,QAAJ,EAAV;;AACA,SAAKO,SAAL;AACD;;AAEDC,EAAAA,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,EAAlB,EAAsB;AAC9B,SAAKL,EAAL,CAAQM,KAAR,CAAcH,KAAd;;AAEA,WAAO,KAAKH,EAAL,CAAQO,MAAR,IAAkB,KAAKC,QAA9B,EAAwC;AACtC,UAAIC,GAAG,GAAG,IAAV;AACA,YAAMC,KAAK,GAAI,KAAKF,QAAL,KAAkB,IAAnB,GACZG,SADY,GAEZ,KAAKX,EAAL,CAAQY,IAAR,CAAa,KAAKJ,QAAlB,CAFF;;AAIA,UAAI;AACFC,QAAAA,GAAG,GAAG,KAAKI,QAAL,CAAcC,IAAd,CAAmBJ,KAAnB,CAAN;AACD,OAFD,CAEE,OAAOK,CAAP,EAAU;AACV,eAAOV,EAAE,CAACU,CAAD,CAAT;AACD;;AAED,UAAI,KAAKP,QAAT,EAAmB;AACjB,aAAKQ,OAAL,GAAe,KAAf;AACD;;AAED,UAAIP,GAAG,CAACQ,IAAR,EAAc;AACZ,aAAKC,IAAL,CAAUT,GAAG,CAACU,KAAd;;AACA,aAAKlB,SAAL;AACD,OAHD,MAGO;AACL,aAAKO,QAAL,GAAgBC,GAAG,CAACU,KAAJ,IAAaC,QAA7B;AACD;AACF;;AAED,WAAOf,EAAE,EAAT;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;AACE;;;AACO,GAANgB,MAAM,GAAG;AAAE;AACV,UAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAEDrB,EAAAA,SAAS,GAAG;AACV,SAAKO,QAAL,GAAgB,IAAhB;AACA,SAAKK,QAAL,GAAgB,KAAKQ,MAAL,EAAhB;AACA,SAAKL,OAAL,GAAe,IAAf;AACD;;AAEDO,EAAAA,MAAM,CAAClB,EAAD,EAAK;AACTA,IAAAA,EAAE,CAAC,KAAKW,OAAL,GAAe,IAAf,GAAsB,IAAIM,KAAJ,CAAU,yBAAV,CAAvB,CAAF;AACD;;AAtE8C;;AAyEjDE,MAAM,CAACC,OAAP,GAAiB9B,iBAAjB","sourcesContent":["// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict'\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @param {stream.TransformOptions} options Stream options.\n   * @memberof BinaryParseStream\n   */\n  constructor(options) {\n    super(options)\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true\n\n    this.bs = new NoFilter()\n    this.__restart()\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh)\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed)\n\n      try {\n        ret = this.__parser.next(chunk)\n      } catch (e) {\n        return cb(e)\n      }\n\n      if (this.__needed) {\n        this.__fresh = false\n      }\n\n      if (ret.done) {\n        this.push(ret.value)\n        this.__restart()\n      } else {\n        this.__needed = ret.value || Infinity\n      }\n    }\n\n    return cb()\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, undefined, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass')\n  }\n\n  __restart() {\n    this.__needed = null\n    this.__parser = this._parse()\n    this.__fresh = true\n  }\n\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'))\n  }\n}\n\nmodule.exports = BinaryParseStream\n"]},"metadata":{},"sourceType":"script"}
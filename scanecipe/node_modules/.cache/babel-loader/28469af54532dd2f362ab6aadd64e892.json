{"ast":null,"code":"'use strict';\n\nconst {\n  MT,\n  SIMPLE,\n  SYMS\n} = require('./constants');\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\n\n\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`);\n    }\n\n    if (value < 0 || value > 255 || (value | 0) !== value) {\n      throw new Error(`value must be a small positive integer: ${value}`);\n    }\n\n    this.value = value;\n  }\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n\n\n  toString() {\n    return `simple(${this.value})`;\n  }\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n\n\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`;\n  }\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n\n\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);\n  }\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n\n\n  static isSimple(obj) {\n    return obj instanceof Simple;\n  }\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n\n\n  static decode(val) {\n    let has_parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let parent_indefinite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false;\n\n      case SIMPLE.TRUE:\n        return true;\n\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null;\n        }\n\n        return SYMS.NULL;\n\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined;\n        }\n\n        return SYMS.UNDEFINED;\n\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK');\n        }\n\n        return SYMS.BREAK;\n\n      default:\n        return new Simple(val);\n    }\n  }\n\n}\n\nmodule.exports = Simple;","map":{"version":3,"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/cbor/lib/simple.js"],"names":["MT","SIMPLE","SYMS","require","Simple","constructor","value","Error","toString","Symbol","for","depth","opts","encodeCBOR","gen","_pushInt","SIMPLE_FLOAT","isSimple","obj","decode","val","has_parent","parent_indefinite","FALSE","TRUE","NULL","UNDEFINED","undefined","BREAK","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAACA,EAAAA,EAAD;AAAKC,EAAAA,MAAL;AAAaC,EAAAA;AAAb,IAAqBC,OAAO,CAAC,aAAD,CAAlC;AAEA;AACA;AACA;;;AACA,MAAMC,MAAN,CAAa;AACX;AACF;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAM,IAAIC,KAAJ,CAAW,wBAAuB,OAAOD,KAAM,EAA/C,CAAN;AACD;;AACD,QAAKA,KAAK,GAAG,CAAT,IAAgBA,KAAK,GAAG,GAAxB,IAAiC,CAACA,KAAK,GAAG,CAAT,MAAgBA,KAArD,EAA6D;AAC3D,YAAM,IAAIC,KAAJ,CAAW,2CAA0CD,KAAM,EAA3D,CAAN;AACD;;AACD,SAAKA,KAAL,GAAaA,KAAb;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEE,EAAAA,QAAQ,GAAG;AACT,WAAQ,UAAS,KAAKF,KAAM,GAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAC2C,GAAxCG,MAAM,CAACC,GAAP,CAAW,4BAAX,CAAwC,EAAEC,KAAF,EAASC,IAAT,EAAe;AACtD,WAAQ,UAAS,KAAKN,KAAM,GAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEO,EAAAA,UAAU,CAACC,GAAD,EAAM;AACd,WAAOA,GAAG,CAACC,QAAJ,CAAa,KAAKT,KAAlB,EAAyBN,EAAE,CAACgB,YAA5B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACiB,SAARC,QAAQ,CAACC,GAAD,EAAM;AACnB,WAAOA,GAAG,YAAYd,MAAtB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAANe,MAAM,CAACC,GAAD,EAAoD;AAAA,QAA9CC,UAA8C,uEAAjC,IAAiC;AAAA,QAA3BC,iBAA2B,uEAAP,KAAO;;AAC/D,YAAQF,GAAR;AACE,WAAKnB,MAAM,CAACsB,KAAZ;AACE,eAAO,KAAP;;AACF,WAAKtB,MAAM,CAACuB,IAAZ;AACE,eAAO,IAAP;;AACF,WAAKvB,MAAM,CAACwB,IAAZ;AACE,YAAIJ,UAAJ,EAAgB;AACd,iBAAO,IAAP;AACD;;AACD,eAAOnB,IAAI,CAACuB,IAAZ;;AACF,WAAKxB,MAAM,CAACyB,SAAZ;AACE,YAAIL,UAAJ,EAAgB;AACd,iBAAOM,SAAP;AACD;;AACD,eAAOzB,IAAI,CAACwB,SAAZ;;AACF,WAAK,CAAC,CAAN;AACE,YAAI,CAACL,UAAD,IAAe,CAACC,iBAApB,EAAuC;AACrC,gBAAM,IAAIf,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,eAAOL,IAAI,CAAC0B,KAAZ;;AACF;AACE,eAAO,IAAIxB,MAAJ,CAAWgB,GAAX,CAAP;AArBJ;AAuBD;;AA7FU;;AAgGbS,MAAM,CAACC,OAAP,GAAiB1B,MAAjB","sourcesContent":["'use strict'\n\nconst {MT, SIMPLE, SYMS} = require('./constants')\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`)\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null\n        }\n        return SYMS.NULL\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined\n        }\n        return SYMS.UNDEFINED\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n"]},"metadata":{},"sourceType":"script"}
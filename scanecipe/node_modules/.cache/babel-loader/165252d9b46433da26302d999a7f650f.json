{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst utils = require('./utils');\n\nconst Decoder = require('./decoder');\n\nconst NoFilter = require('nofilter');\n\nconst {\n  MT,\n  NUMBYTES,\n  SYMS\n} = require('./constants');\n\nconst {\n  Buffer\n} = require('buffer');\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  }\n\n  return '';\n}\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\n\n\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb:\n        /** @type {commentCallback} */\n        opts\n      };\n\n    case 'string':\n      return {\n        options: {\n          encoding:\n          /** @type {BufferEncoding} */\n          opts\n        },\n        cb\n      };\n\n    case 'number':\n      return {\n        options: {\n          max_depth: opts\n        },\n        cb\n      };\n\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\n\n\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n    super({ ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    this.depth = depth;\n    this.max_depth = max_depth;\n    this.all = new NoFilter();\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this);\n    }\n\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding\n    });\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('start-string', this._on_start_string.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this));\n    }\n\n    this.parser.bs.on('read', this._on_read.bind(this));\n  }\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n\n\n  _tag_24(v) {\n    const c = new Commented({\n      depth: this.depth + 1,\n      no_summary: true\n    });\n    c.on('data', b => this.push(b));\n    c.on('error', er => this.emit('error', er));\n    c.end(v);\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb);\n  }\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   */\n\n\n  static comment(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const bs = new NoFilter();\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const d = new Commented(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'));\n      });\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'));\n        });\n        d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_error(er) {\n    this.push('ERROR: ');\n    this.push(er.toString());\n    this.push('\\n');\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_read(buf) {\n    this.all.write(buf);\n    const hex = buf.toString('hex');\n    this.push(new Array(this.depth + 1).join('  '));\n    this.push(hex);\n    let ind = (this.max_depth - this.depth) * 2 - hex.length;\n\n    if (ind < 1) {\n      ind = 1;\n    }\n\n    this.push(new Array(ind + 1).join(' '));\n    this.push('-- ');\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = '';\n    this.depth++;\n\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,';\n        break;\n\n      case MT.NEG_INT:\n        desc = 'Negative number,';\n        break;\n\n      case MT.ARRAY:\n        desc = 'Array, length';\n        break;\n\n      case MT.MAP:\n        desc = 'Map, count';\n        break;\n\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length';\n        break;\n\n      case MT.UTF8_STRING:\n        desc = 'String, length';\n        break;\n\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,';\n        } else {\n          desc = 'Float,';\n        }\n\n        break;\n    }\n\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`);\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = '';\n    this.depth++;\n\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`;\n        break;\n\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`;\n        break;\n    }\n\n    this.push(`${desc}\\n`);\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++;\n\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `);\n        break;\n\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `);\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `);\n        }\n\n        break;\n    }\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`);\n\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item');\n        }\n\n        break;\n\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)');\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`);\n        }\n\n        break;\n\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)');\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`);\n        }\n\n        break;\n\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)');\n        break;\n\n      case MT.UTF8_STRING:\n        this.push('String (streaming)');\n        break;\n    }\n\n    this.push('\\n');\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_stop(mt) {\n    this.depth--;\n  }\n  /**\n   * @private\n   */\n\n\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `);\n          break;\n\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `);\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `);\n          }\n\n          break;\n      }\n    }\n\n    const str = utils.cborValueToString(val, -Infinity);\n\n    if (typeof val === 'string' || Buffer.isBuffer(val)) {\n      if (val.length > 0) {\n        this.push(str);\n        this.push('\\n');\n      }\n\n      this.depth--;\n    } else {\n      this.push(str);\n      this.push('\\n');\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--;\n    }\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_data() {\n    this.push('0x');\n    this.push(this.all.read().toString('hex'));\n    this.push('\\n');\n  }\n\n}\n\nmodule.exports = Commented;","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/cbor/lib/commented.js"],"names":["stream","require","utils","Decoder","NoFilter","MT","NUMBYTES","SYMS","Buffer","plural","c","normalizeOptions","opts","cb","options","encoding","max_depth","TypeError","Commented","Transform","constructor","depth","no_summary","tags","preferWeb","superOpts","readableObjectMode","writableObjectMode","all","_tag_24","bind","parser","on","_on_value","_on_start","_on_start_string","_on_stop","_on_more","_on_error","_on_data","bs","_on_read","v","b","push","er","emit","end","_transform","fresh","write","_flush","comment","input","Error","d","p","toString","Promise","resolve","reject","pipe","guessEncoding","buf","hex","Array","join","ind","length","mt","len","parent_mt","pos","desc","POS_INT","NEG_INT","ARRAY","MAP","BYTE_STRING","UTF8_STRING","SIMPLE_FLOAT","tag","Math","floor","TAG","STREAM","val","ai","BREAK","str","cborValueToString","Infinity","isBuffer","ONE","TWO","FOUR","EIGHT","read","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst utils = require('./utils')\nconst Decoder = require('./decoder')\nconst NoFilter = require('nofilter')\nconst {MT, NUMBYTES, SYMS} = require('./constants')\nconst {Buffer} = require('buffer')\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's'\n  }\n  return ''\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'number':\n      return {options: {max_depth: opts}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.depth = depth\n    this.max_depth = max_depth\n    this.all = new NoFilter()\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this)\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('start-string', this._on_start_string.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this))\n    }\n    this.parser.bs.on('read', this._on_read.bind(this))\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true})\n\n    c.on('data', b => this.push(b))\n    c.on('error', er => this.emit('error', er))\n    c.end(v)\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb)\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const bs = new NoFilter()\n    const {encoding = 'hex', ...opts} = options\n    const d = new Commented(opts)\n    let p = null\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'))\n      })\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'))\n        })\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ')\n    this.push(er.toString())\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf)\n    const hex = buf.toString('hex')\n\n    this.push(new Array(this.depth + 1).join('  '))\n    this.push(hex)\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length\n    if (ind < 1) {\n      ind = 1\n    }\n    this.push(new Array(ind + 1).join(' '))\n    this.push('-- ')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,'\n        break\n      case MT.NEG_INT:\n        desc = 'Negative number,'\n        break\n      case MT.ARRAY:\n        desc = 'Array, length'\n        break\n      case MT.MAP:\n        desc = 'Map, count'\n        break\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length'\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length'\n        break\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,'\n        } else {\n          desc = 'Float,'\n        }\n        break\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`\n        break\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`\n        break\n    }\n    this.push(`${desc}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `)\n        break\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `)\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `)\n        }\n        break\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`)\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item')\n        }\n        break\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)')\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`)\n        }\n        break\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)')\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`)\n        }\n        break\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)')\n        break\n      case MT.UTF8_STRING:\n        this.push('String (streaming)')\n        break\n    }\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(mt) {\n    this.depth--\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity)\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str)\n        this.push('\\n')\n      }\n      this.depth--\n    } else {\n      this.push(str)\n      this.push('\\n')\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x')\n    this.push(this.all.read().toString('hex'))\n    this.push('\\n')\n  }\n}\n\nmodule.exports = Commented\n"]},"metadata":{},"sourceType":"script"}
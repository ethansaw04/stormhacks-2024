{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst td = new TextDecoder('utf8', {\n  fatal: true,\n  ignoreBOM: true\n});\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\n\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let inp = null;\n    let inpE =\n    /** @type {BufferEncoding?} */\n    null;\n\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input;\n        } else if (input) {\n          options = input;\n        }\n\n        break;\n\n      case 'string':\n        inp = input;\n        break;\n\n      case 'undefined':\n        break;\n\n      default:\n        throw new TypeError('Invalid input');\n    }\n\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding;\n        }\n\n        break;\n\n      case 'string':\n        inpE =\n        /** @type {BufferEncoding} */\n        inputEncoding;\n        break;\n\n      case 'undefined':\n        break;\n\n      default:\n        throw new TypeError('Invalid inputEncoding');\n    }\n\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options');\n    }\n\n    if (inp == null) {\n      inp = options.input;\n    }\n\n    if (inpE == null) {\n      inpE = options.inputEncoding;\n    }\n\n    delete options.input;\n    delete options.inputEncoding;\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe;\n    delete options.watchPipe;\n    const readError = Boolean(options.readError);\n    delete options.readError;\n    super(options);\n    this.readError = readError;\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode; // @ts-ignore: TS2339 (using internal interface)\n\n        if (this.length > 0 && om !== this._readableState.objectMode) {\n          throw new Error('Do not switch objectMode in the middle of the stream');\n        } // @ts-ignore: TS2339 (using internal interface)\n\n\n        this._readableState.objectMode = om; // @ts-ignore: TS2339 (using internal interface)\n\n        this._writableState.objectMode = om;\n      });\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE);\n    }\n  }\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n\n\n  static isNoFilter(obj) {\n    return obj instanceof this;\n  }\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n\n\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n\n    if (nf1 === nf2) {\n      return 0;\n    }\n\n    return nf1.compare(nf2);\n  }\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n\n\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters');\n    }\n\n    if (list.length === 0 || length === 0) {\n      return Buffer.alloc(0);\n    }\n\n    if (length == null) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters');\n        }\n\n        return tot + nf.length;\n      }, 0);\n    }\n\n    let allBufs = true;\n    let allObjs = true;\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters');\n      }\n\n      const buf = nf.slice();\n\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false;\n      } else {\n        allBufs = false;\n      }\n\n      return buf;\n    });\n\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length);\n    }\n\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length);\n    } // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n\n\n    throw new Error('Concatenating mixed object and byte streams not supported');\n  }\n  /**\n   * @ignore\n   */\n\n\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.push(chunk);\n    callback();\n  }\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n\n\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer; // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head;\n      bufs = [];\n\n      while (b != null) {\n        bufs.push(b.data);\n        b = b.next;\n      }\n    }\n\n    return bufs;\n  }\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n\n\n  read(size) {\n    const buf = super.read(size);\n\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf);\n\n      if (this.readError && buf.length < size) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`);\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`);\n    }\n\n    return buf;\n  }\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n\n\n  readFull(size) {\n    let onReadable = null;\n    let onFinish = null;\n    let onError = null;\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size));\n        return;\n      } // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n\n\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`));\n        return;\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size));\n        }\n      };\n\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`));\n      };\n\n      onError = reject;\n      this.on('readable', onReadable);\n      this.on('error', onError);\n      this.on('finish', onFinish);\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable);\n        this.removeListener('error', onError);\n        this.removeListener('finish', onFinish);\n      }\n    });\n  }\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n\n\n  promise(cb) {\n    let done = false;\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read();\n\n        if (cb != null && !done) {\n          done = true;\n          cb(null, data);\n        }\n\n        resolve(data);\n      });\n      this.on('error', er => {\n        if (cb != null && !done) {\n          done = true;\n          cb(er);\n        }\n\n        reject(er);\n      });\n    });\n  }\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n\n\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n\n    if (this === other) {\n      return 0;\n    }\n\n    const buf1 = this.slice();\n    const buf2 = other.slice(); // These will both be buffers because of the check above.\n\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2);\n    }\n\n    throw new Error('Cannot compare streams in object mode');\n  }\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n\n\n  equals(other) {\n    return this.compare(other) === 0;\n  }\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n\n\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end);\n    }\n\n    const bufs = this._bufArray();\n\n    switch (bufs.length) {\n      case 0:\n        return Buffer.alloc(0);\n\n      case 1:\n        return bufs[0].slice(start, end);\n\n      default:\n        {\n          const b = Buffer.concat(bufs); // TODO: store the concatented bufs back\n          // @_readableState.buffer = [b]\n\n          return b.slice(start, end);\n        }\n    }\n  }\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n\n\n  get(index) {\n    return this.slice()[index];\n  }\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n\n\n  toJSON() {\n    const b = this.slice();\n\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON();\n    }\n\n    return b;\n  }\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n\n\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end);\n\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf);\n    }\n\n    if (!encoding || encoding === 'utf8') {\n      return td.decode(buf);\n    }\n\n    return buf.toString(encoding);\n  }\n  /**\n   * @ignore\n   */\n\n\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray();\n\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string');\n      }\n\n      return JSON.stringify(b);\n    }).join(', ');\n    return `${this.constructor.name} [${hex}]`;\n  }\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n\n\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length;\n  }\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeBigInt(val) {\n    let str = val.toString(16);\n\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2));\n      const mask = BigInt(1) << sz * BigInt(8);\n      val = mask + val;\n      str = val.toString(16);\n    }\n\n    if (str.length % 2) {\n      str = `0${str}`;\n    }\n\n    return this.push(Buffer.from(str, 'hex'));\n  }\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n\n\n  readUBigInt(len) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return BigInt(`0x${b.toString('hex')}`);\n  }\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n\n\n  readBigInt(len) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    let ret = BigInt(`0x${b.toString('hex')}`); // Negative?\n\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << BigInt(b.length) * BigInt(8);\n      ret -= mask;\n    }\n\n    return ret;\n  }\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeUInt8(value) {\n    const b = Buffer.from([value]);\n    return this.push(b);\n  }\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32LE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32BE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeInt8(value) {\n    const b = Buffer.from([value]);\n    return this.push(b);\n  }\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n\n\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32LE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n\n\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32BE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4);\n    b.writeFloatLE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4);\n    b.writeFloatBE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8);\n    b.writeDoubleLE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8);\n    b.writeDoubleBE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigInt64LE(value);\n    return this.push(b);\n  }\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigInt64BE(value);\n    return this.push(b);\n  }\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigUInt64LE(value);\n    return this.push(b);\n  }\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n\n\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8);\n    b.writeBigUInt64BE(value);\n    return this.push(b);\n  }\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readUInt8() {\n    const b = this.read(1);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readUInt8();\n  }\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readUInt16LE() {\n    const b = this.read(2);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readUInt16LE();\n  }\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readUInt16BE() {\n    const b = this.read(2);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readUInt16BE();\n  }\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readUInt32LE() {\n    const b = this.read(4);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readUInt32LE();\n  }\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readUInt32BE() {\n    const b = this.read(4);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readUInt32BE();\n  }\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readInt8() {\n    const b = this.read(1);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readInt8();\n  }\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readInt16LE() {\n    const b = this.read(2);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readInt16LE();\n  }\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readInt16BE() {\n    const b = this.read(2);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readInt16BE();\n  }\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readInt32LE() {\n    const b = this.read(4);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readInt32LE();\n  }\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readInt32BE() {\n    const b = this.read(4);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readInt32BE();\n  }\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readFloatLE() {\n    const b = this.read(4);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readFloatLE();\n  }\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readFloatBE() {\n    const b = this.read(4);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readFloatBE();\n  }\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readDoubleLE() {\n    const b = this.read(8);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readDoubleLE();\n  }\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n\n\n  readDoubleBE() {\n    const b = this.read(8);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readDoubleBE();\n  }\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n\n\n  readBigInt64LE() {\n    const b = this.read(8);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readBigInt64LE();\n  }\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n\n\n  readBigInt64BE() {\n    const b = this.read(8);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readBigInt64BE();\n  }\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n\n\n  readBigUInt64LE() {\n    const b = this.read(8);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readBigUInt64LE();\n  }\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n\n\n  readBigUInt64BE() {\n    const b = this.read(8);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b.readBigUInt64BE();\n  }\n\n}\n\nmodule.exports = NoFilter;","map":{"version":3,"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/nofilter/lib/index.js"],"names":["stream","require","Buffer","td","TextDecoder","fatal","ignoreBOM","NoFilter","Transform","constructor","input","inputEncoding","options","inp","inpE","isBuffer","TypeError","watchPipe","readError","Boolean","on","readable","om","_readableState","objectMode","length","Error","_writableState","end","isNoFilter","obj","compare","nf1","nf2","concat","list","Array","isArray","alloc","reduce","tot","nf","allBufs","allObjs","bufs","map","buf","slice","_transform","chunk","encoding","callback","from","push","_bufArray","buffer","b","head","data","next","read","size","emit","readFull","onReadable","onFinish","onError","Promise","resolve","reject","writableFinished","finally","removeListener","promise","cb","done","er","other","buf1","buf2","equals","start","get","index","toJSON","toString","JSON","stringify","decode","Symbol","for","depth","hex","stylize","join","name","writeBigInt","val","str","sz","BigInt","Math","floor","mask","readUBigInt","len","readBigInt","ret","writeUInt8","value","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","writeBigInt64LE","writeBigInt64BE","writeBigUInt64LE","writeBigUInt64BE","readUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","readBigInt64LE","readBigInt64BE","readBigUInt64LE","readBigUInt64BE","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAWD,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAME,EAAE,GAAG,IAAIC,WAAJ,CAAgB,MAAhB,EAAwB;AAACC,EAAAA,KAAK,EAAE,IAAR;AAAcC,EAAAA,SAAS,EAAE;AAAzB,CAAxB,CAAX;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAN,SAAuBP,MAAM,CAACQ,SAA9B,CAAwC;AACtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,KAAD,EAAQC,aAAR,EAAqC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAC9C,QAAIC,GAAG,GAAG,IAAV;AACA,QAAIC,IAAI;AAAG;AAAgC,QAA3C;;AACA,YAAQ,OAAOJ,KAAf;AACE,WAAK,QAAL;AACE,YAAIR,MAAM,CAACa,QAAP,CAAgBL,KAAhB,CAAJ,EAA4B;AAC1BG,UAAAA,GAAG,GAAGH,KAAN;AACD,SAFD,MAEO,IAAIA,KAAJ,EAAW;AAChBE,UAAAA,OAAO,GAAGF,KAAV;AACD;;AACD;;AACF,WAAK,QAAL;AACEG,QAAAA,GAAG,GAAGH,KAAN;AACA;;AACF,WAAK,WAAL;AACE;;AACF;AACE,cAAM,IAAIM,SAAJ,CAAc,eAAd,CAAN;AAdJ;;AAgBA,YAAQ,OAAOL,aAAf;AACE,WAAK,QAAL;AACE,YAAIA,aAAJ,EAAmB;AACjBC,UAAAA,OAAO,GAAGD,aAAV;AACD;;AACD;;AACF,WAAK,QAAL;AACEG,QAAAA,IAAI;AAAG;AAA+BH,QAAAA,aAAtC;AACA;;AACF,WAAK,WAAL;AACE;;AACF;AACE,cAAM,IAAIK,SAAJ,CAAc,uBAAd,CAAN;AAZJ;;AAcA,QAAI,CAACJ,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAAnC,EAA6C;AAC3C,YAAM,IAAII,SAAJ,CAAc,iBAAd,CAAN;AACD;;AACD,QAAIH,GAAG,IAAI,IAAX,EAAiB;AACfA,MAAAA,GAAG,GAAGD,OAAO,CAACF,KAAd;AACD;;AACD,QAAII,IAAI,IAAI,IAAZ,EAAkB;AAChBA,MAAAA,IAAI,GAAGF,OAAO,CAACD,aAAf;AACD;;AACD,WAAOC,OAAO,CAACF,KAAf;AACA,WAAOE,OAAO,CAACD,aAAf;AACA,UAAMM,SAAS,GAAGL,OAAO,CAACK,SAAR,IAAqB,IAArB,GAA4B,IAA5B,GAAmCL,OAAO,CAACK,SAA7D;AACA,WAAOL,OAAO,CAACK,SAAf;AACA,UAAMC,SAAS,GAAGC,OAAO,CAACP,OAAO,CAACM,SAAT,CAAzB;AACA,WAAON,OAAO,CAACM,SAAf;AACA,UAAMN,OAAN;AAEA,SAAKM,SAAL,GAAiBA,SAAjB;;AAEA,QAAID,SAAJ,EAAe;AACb,WAAKG,EAAL,CAAQ,MAAR,EAAgBC,QAAQ,IAAI;AAC1B;AACA,cAAMC,EAAE,GAAGD,QAAQ,CAACE,cAAT,CAAwBC,UAAnC,CAF0B,CAG1B;;AACA,YAAK,KAAKC,MAAL,GAAc,CAAf,IAAsBH,EAAE,KAAK,KAAKC,cAAL,CAAoBC,UAArD,EAAkE;AAChE,gBAAM,IAAIE,KAAJ,CACJ,sDADI,CAAN;AAGD,SARyB,CAU1B;;;AACA,aAAKH,cAAL,CAAoBC,UAApB,GAAiCF,EAAjC,CAX0B,CAY1B;;AACA,aAAKK,cAAL,CAAoBH,UAApB,GAAiCF,EAAjC;AACD,OAdD;AAeD;;AAED,QAAIT,GAAG,IAAI,IAAX,EAAiB;AACf,WAAKe,GAAL,CAASf,GAAT,EAAcC,IAAd;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;AACmB,SAAVe,UAAU,CAACC,GAAD,EAAM;AACrB,WAAOA,GAAG,YAAY,IAAtB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,SAAPC,OAAO,CAACC,GAAD,EAAMC,GAAN,EAAW;AACvB,QAAI,EAAED,GAAG,YAAY,IAAjB,CAAJ,EAA4B;AAC1B,YAAM,IAAIhB,SAAJ,CAAc,6BAAd,CAAN;AACD;;AACD,QAAIgB,GAAG,KAAKC,GAAZ,EAAiB;AACf,aAAO,CAAP;AACD;;AACD,WAAOD,GAAG,CAACD,OAAJ,CAAYE,GAAZ,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAANC,MAAM,CAACC,IAAD,EAAOV,MAAP,EAAe;AAC1B,QAAI,CAACW,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxB,YAAM,IAAInB,SAAJ,CAAc,6CAAd,CAAN;AACD;;AACD,QAAKmB,IAAI,CAACV,MAAL,KAAgB,CAAjB,IAAwBA,MAAM,KAAK,CAAvC,EAA2C;AACzC,aAAOvB,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAP;AACD;;AACD,QAAKb,MAAM,IAAI,IAAf,EAAsB;AACpBA,MAAAA,MAAM,GAAGU,IAAI,CAACI,MAAL,CAAY,CAACC,GAAD,EAAMC,EAAN,KAAa;AAChC,YAAI,EAAEA,EAAE,YAAYlC,QAAhB,CAAJ,EAA+B;AAC7B,gBAAM,IAAIS,SAAJ,CAAc,6CAAd,CAAN;AACD;;AACD,eAAOwB,GAAG,GAAGC,EAAE,CAAChB,MAAhB;AACD,OALQ,EAKN,CALM,CAAT;AAMD;;AACD,QAAIiB,OAAO,GAAG,IAAd;AACA,QAAIC,OAAO,GAAG,IAAd;AACA,UAAMC,IAAI,GAAGT,IAAI,CAACU,GAAL,CAASJ,EAAE,IAAI;AAC1B,UAAI,EAAEA,EAAE,YAAYlC,QAAhB,CAAJ,EAA+B;AAC7B,cAAM,IAAIS,SAAJ,CAAc,6CAAd,CAAN;AACD;;AACD,YAAM8B,GAAG,GAAGL,EAAE,CAACM,KAAH,EAAZ;;AACA,UAAI7C,MAAM,CAACa,QAAP,CAAgB+B,GAAhB,CAAJ,EAA0B;AACxBH,QAAAA,OAAO,GAAG,KAAV;AACD,OAFD,MAEO;AACLD,QAAAA,OAAO,GAAG,KAAV;AACD;;AACD,aAAOI,GAAP;AACD,KAXY,CAAb;;AAYA,QAAIJ,OAAJ,EAAa;AACX;AACA,aAAOxC,MAAM,CAACgC,MAAP,CAAcU,IAAd,EAAoBnB,MAApB,CAAP;AACD;;AACD,QAAIkB,OAAJ,EAAa;AACX,aAAO,GAAGT,MAAH,CAAU,GAAGU,IAAb,EAAmBG,KAAnB,CAAyB,CAAzB,EAA4BtB,MAA5B,CAAP;AACD,KAnCyB,CAoC1B;AACA;;;AACA,UAAM,IAAIC,KAAJ,CAAU,2DAAV,CAAN;AACD;AAED;AACF;AACA;;;AACEsB,EAAAA,UAAU,CAACC,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,EAA4B;AACpC;AACA,QAAI,CAAC,KAAK5B,cAAL,CAAoBC,UAArB,IAAmC,CAACtB,MAAM,CAACa,QAAP,CAAgBkC,KAAhB,CAAxC,EAAgE;AAC9DA,MAAAA,KAAK,GAAG/C,MAAM,CAACkD,IAAP,CAAYH,KAAZ,EAAmBC,QAAnB,CAAR;AACD;;AACD,SAAKG,IAAL,CAAUJ,KAAV;AACAE,IAAAA,QAAQ;AACT;AAED;AACF;AACA;AACA;AACA;;;AACEG,EAAAA,SAAS,GAAG;AACV;AACA,QAAIV,IAAI,GAAG,KAAKrB,cAAL,CAAoBgC,MAA/B,CAFU,CAGV;AACA;;AACA,QAAI,CAACnB,KAAK,CAACC,OAAN,CAAcO,IAAd,CAAL,EAA0B;AACxB,UAAIY,CAAC,GAAGZ,IAAI,CAACa,IAAb;AACAb,MAAAA,IAAI,GAAG,EAAP;;AACA,aAAOY,CAAC,IAAI,IAAZ,EAAkB;AAChBZ,QAAAA,IAAI,CAACS,IAAL,CAAUG,CAAC,CAACE,IAAZ;AACAF,QAAAA,CAAC,GAAGA,CAAC,CAACG,IAAN;AACD;AACF;;AACD,WAAOf,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEgB,EAAAA,IAAI,CAACC,IAAD,EAAO;AACT,UAAMf,GAAG,GAAG,MAAMc,IAAN,CAAWC,IAAX,CAAZ;;AACA,QAAIf,GAAG,IAAI,IAAX,EAAiB;AACf;AACN;AACA;AACA;AACA;AACA;AACM,WAAKgB,IAAL,CAAU,MAAV,EAAkBhB,GAAlB;;AACA,UAAI,KAAK5B,SAAL,IAAmB4B,GAAG,CAACrB,MAAJ,GAAaoC,IAApC,EAA2C;AACzC,cAAM,IAAInC,KAAJ,CAAW,QAAOoB,GAAG,CAACrB,MAAO,YAAWoC,IAAK,EAA7C,CAAN;AACD;AACF,KAXD,MAWO,IAAI,KAAK3C,SAAT,EAAoB;AACzB,YAAM,IAAIQ,KAAJ,CAAW,6BAA4BmC,IAAK,EAA5C,CAAN;AACD;;AACD,WAAOf,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEiB,EAAAA,QAAQ,CAACF,IAAD,EAAO;AACb,QAAIG,UAAU,GAAG,IAAjB;AACA,QAAIC,QAAQ,GAAG,IAAf;AACA,QAAIC,OAAO,GAAG,IAAd;AACA,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAI,KAAK5C,MAAL,IAAeoC,IAAnB,EAAyB;AACvBO,QAAAA,OAAO,CAAC,KAAKR,IAAL,CAAUC,IAAV,CAAD,CAAP;AACA;AACD,OAJqC,CAMtC;AACA;;;AACA,UAAI,KAAKS,gBAAT,EAA2B;AACzB;AACAD,QAAAA,MAAM,CAAC,IAAI3C,KAAJ,CAAW,0BAAyBmC,IAAK,uBAAzC,CAAD,CAAN;AACA;AACD;;AAEDG,MAAAA,UAAU,GAAGf,KAAK,IAAI;AACpB,YAAI,KAAKxB,MAAL,IAAeoC,IAAnB,EAAyB;AACvBO,UAAAA,OAAO,CAAC,KAAKR,IAAL,CAAUC,IAAV,CAAD,CAAP;AACD;AACF,OAJD;;AAKAI,MAAAA,QAAQ,GAAG,MAAM;AACfI,QAAAA,MAAM,CAAC,IAAI3C,KAAJ,CAAW,0BAAyBmC,IAAK,uBAAzC,CAAD,CAAN;AACD,OAFD;;AAGAK,MAAAA,OAAO,GAAGG,MAAV;AACA,WAAKjD,EAAL,CAAQ,UAAR,EAAoB4C,UAApB;AACA,WAAK5C,EAAL,CAAQ,OAAR,EAAiB8C,OAAjB;AACA,WAAK9C,EAAL,CAAQ,QAAR,EAAkB6C,QAAlB;AACD,KA1BM,EA0BJM,OA1BI,CA0BI,MAAM;AACf,UAAIP,UAAJ,EAAgB;AACd,aAAKQ,cAAL,CAAoB,UAApB,EAAgCR,UAAhC;AACA,aAAKQ,cAAL,CAAoB,OAApB,EAA6BN,OAA7B;AACA,aAAKM,cAAL,CAAoB,QAApB,EAA8BP,QAA9B;AACD;AACF,KAhCM,CAAP;AAiCD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEQ,EAAAA,OAAO,CAACC,EAAD,EAAK;AACV,QAAIC,IAAI,GAAG,KAAX;AACA,WAAO,IAAIR,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKjD,EAAL,CAAQ,QAAR,EAAkB,MAAM;AACtB,cAAMsC,IAAI,GAAG,KAAKE,IAAL,EAAb;;AACA,YAAKc,EAAE,IAAI,IAAP,IAAgB,CAACC,IAArB,EAA2B;AACzBA,UAAAA,IAAI,GAAG,IAAP;AACAD,UAAAA,EAAE,CAAC,IAAD,EAAOhB,IAAP,CAAF;AACD;;AACDU,QAAAA,OAAO,CAACV,IAAD,CAAP;AACD,OAPD;AAQA,WAAKtC,EAAL,CAAQ,OAAR,EAAiBwD,EAAE,IAAI;AACrB,YAAKF,EAAE,IAAI,IAAP,IAAgB,CAACC,IAArB,EAA2B;AACzBA,UAAAA,IAAI,GAAG,IAAP;AACAD,UAAAA,EAAE,CAACE,EAAD,CAAF;AACD;;AACDP,QAAAA,MAAM,CAACO,EAAD,CAAN;AACD,OAND;AAOD,KAhBM,CAAP;AAiBD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE7C,EAAAA,OAAO,CAAC8C,KAAD,EAAQ;AACb,QAAI,EAAEA,KAAK,YAAYtE,QAAnB,CAAJ,EAAkC;AAChC,YAAM,IAAIS,SAAJ,CAAc,6BAAd,CAAN;AACD;;AACD,QAAI,SAAS6D,KAAb,EAAoB;AAClB,aAAO,CAAP;AACD;;AAED,UAAMC,IAAI,GAAG,KAAK/B,KAAL,EAAb;AACA,UAAMgC,IAAI,GAAGF,KAAK,CAAC9B,KAAN,EAAb,CATa,CAUb;;AACA,QAAI7C,MAAM,CAACa,QAAP,CAAgB+D,IAAhB,KAAyB5E,MAAM,CAACa,QAAP,CAAgBgE,IAAhB,CAA7B,EAAoD;AAClD,aAAOD,IAAI,CAAC/C,OAAL,CAAagD,IAAb,CAAP;AACD;;AACD,UAAM,IAAIrD,KAAJ,CAAU,uCAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEsD,EAAAA,MAAM,CAACH,KAAD,EAAQ;AACZ,WAAO,KAAK9C,OAAL,CAAa8C,KAAb,MAAwB,CAA/B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE9B,EAAAA,KAAK,CAACkC,KAAD,EAAQrD,GAAR,EAAa;AAChB;AACA,QAAI,KAAKL,cAAL,CAAoBC,UAAxB,EAAoC;AAClC,aAAO,KAAK8B,SAAL,GAAiBP,KAAjB,CAAuBkC,KAAvB,EAA8BrD,GAA9B,CAAP;AACD;;AACD,UAAMgB,IAAI,GAAG,KAAKU,SAAL,EAAb;;AACA,YAAQV,IAAI,CAACnB,MAAb;AACE,WAAK,CAAL;AAAQ,eAAOvB,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAP;;AACR,WAAK,CAAL;AAAQ,eAAOM,IAAI,CAAC,CAAD,CAAJ,CAAQG,KAAR,CAAckC,KAAd,EAAqBrD,GAArB,CAAP;;AACR;AAAS;AACP,gBAAM4B,CAAC,GAAGtD,MAAM,CAACgC,MAAP,CAAcU,IAAd,CAAV,CADO,CAEP;AACA;;AACA,iBAAOY,CAAC,CAACT,KAAF,CAAQkC,KAAR,EAAerD,GAAf,CAAP;AACD;AARH;AAUD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEsD,EAAAA,GAAG,CAACC,KAAD,EAAQ;AACT,WAAO,KAAKpC,KAAL,GAAaoC,KAAb,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,MAAM,GAAG;AACP,UAAM5B,CAAC,GAAG,KAAKT,KAAL,EAAV;;AACA,QAAI7C,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAJ,EAAwB;AACtB,aAAOA,CAAC,CAAC4B,MAAF,EAAP;AACD;;AACD,WAAO5B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE6B,EAAAA,QAAQ,CAACnC,QAAD,EAAW+B,KAAX,EAAkBrD,GAAlB,EAAuB;AAC7B,UAAMkB,GAAG,GAAG,KAAKC,KAAL,CAAWkC,KAAX,EAAkBrD,GAAlB,CAAZ;;AACA,QAAI,CAAC1B,MAAM,CAACa,QAAP,CAAgB+B,GAAhB,CAAL,EAA2B;AACzB,aAAOwC,IAAI,CAACC,SAAL,CAAezC,GAAf,CAAP;AACD;;AACD,QAAI,CAACI,QAAD,IAAcA,QAAQ,KAAK,MAA/B,EAAwC;AACtC,aAAO/C,EAAE,CAACqF,MAAH,CAAU1C,GAAV,CAAP;AACD;;AACD,WAAOA,GAAG,CAACuC,QAAJ,CAAanC,QAAb,CAAP;AACD;AAED;AACF;AACA;;;AAC2C,GAAxCuC,MAAM,CAACC,GAAP,CAAW,4BAAX,CAAwC,EAAEC,KAAF,EAAS/E,OAAT,EAAkB;AACzD,UAAMgC,IAAI,GAAG,KAAKU,SAAL,EAAb;;AACA,UAAMsC,GAAG,GAAGhD,IAAI,CAACC,GAAL,CAASW,CAAC,IAAI;AACxB,UAAItD,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAJ,EAAwB;AACtB,eAAO5C,OAAO,CAACiF,OAAR,CAAgBrC,CAAC,CAAC6B,QAAF,CAAW,KAAX,CAAhB,EAAmC,QAAnC,CAAP;AACD;;AACD,aAAOC,IAAI,CAACC,SAAL,CAAe/B,CAAf,CAAP;AACD,KALW,EAKTsC,IALS,CAKJ,IALI,CAAZ;AAMA,WAAQ,GAAE,KAAKrF,WAAL,CAAiBsF,IAAK,KAAIH,GAAI,GAAxC;AACD;AAED;AACF;AACA;AACA;AACA;;;AACY,MAANnE,MAAM,GAAG;AACX;AACA,WAAO,KAAKF,cAAL,CAAoBE,MAA3B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEuE,EAAAA,WAAW,CAACC,GAAD,EAAM;AACf,QAAIC,GAAG,GAAGD,GAAG,CAACZ,QAAJ,CAAa,EAAb,CAAV;;AACA,QAAIY,GAAG,GAAG,CAAV,EAAa;AACX;AACA;AACA,YAAME,EAAE,GAAGC,MAAM,CAACC,IAAI,CAACC,KAAL,CAAWJ,GAAG,CAACzE,MAAJ,GAAa,CAAxB,CAAD,CAAjB;AACA,YAAM8E,IAAI,GAAGH,MAAM,CAAC,CAAD,CAAN,IAAcD,EAAE,GAAGC,MAAM,CAAC,CAAD,CAAtC;AACAH,MAAAA,GAAG,GAAGM,IAAI,GAAGN,GAAb;AACAC,MAAAA,GAAG,GAAGD,GAAG,CAACZ,QAAJ,CAAa,EAAb,CAAN;AACD;;AACD,QAAIa,GAAG,CAACzE,MAAJ,GAAa,CAAjB,EAAoB;AAClByE,MAAAA,GAAG,GAAI,IAAGA,GAAI,EAAd;AACD;;AACD,WAAO,KAAK7C,IAAL,CAAUnD,MAAM,CAACkD,IAAP,CAAY8C,GAAZ,EAAiB,KAAjB,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEM,EAAAA,WAAW,CAACC,GAAD,EAAM;AACf,UAAMjD,CAAC,GAAG,KAAKI,IAAL,CAAU6C,GAAV,CAAV;;AACA,QAAI,CAACvG,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAO4C,MAAM,CAAE,KAAI5C,CAAC,CAAC6B,QAAF,CAAW,KAAX,CAAkB,EAAxB,CAAb;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEqB,EAAAA,UAAU,CAACD,GAAD,EAAM;AACd,UAAMjD,CAAC,GAAG,KAAKI,IAAL,CAAU6C,GAAV,CAAV;;AACA,QAAI,CAACvG,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,QAAImD,GAAG,GAAGP,MAAM,CAAE,KAAI5C,CAAC,CAAC6B,QAAF,CAAW,KAAX,CAAkB,EAAxB,CAAhB,CALc,CAMd;;AACA,QAAI7B,CAAC,CAAC,CAAD,CAAD,GAAO,IAAX,EAAiB;AACf;AACA,YAAM+C,IAAI,GAAGH,MAAM,CAAC,CAAD,CAAN,IAAcA,MAAM,CAAC5C,CAAC,CAAC/B,MAAH,CAAN,GAAmB2E,MAAM,CAAC,CAAD,CAApD;AACAO,MAAAA,GAAG,IAAIJ,IAAP;AACD;;AACD,WAAOI,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,UAAU,CAACC,KAAD,EAAQ;AAChB,UAAMrD,CAAC,GAAGtD,MAAM,CAACkD,IAAP,CAAY,CAACyD,KAAD,CAAZ,CAAV;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEsD,EAAAA,aAAa,CAACD,KAAD,EAAQ;AACnB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACsD,aAAF,CAAgBD,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEuD,EAAAA,aAAa,CAACF,KAAD,EAAQ;AACnB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACuD,aAAF,CAAgBF,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEwD,EAAAA,aAAa,CAACH,KAAD,EAAQ;AACnB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACwD,aAAF,CAAgBH,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEyD,EAAAA,aAAa,CAACJ,KAAD,EAAQ;AACnB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACyD,aAAF,CAAgBJ,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE0D,EAAAA,SAAS,CAACL,KAAD,EAAQ;AACf,UAAMrD,CAAC,GAAGtD,MAAM,CAACkD,IAAP,CAAY,CAACyD,KAAD,CAAZ,CAAV;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE2D,EAAAA,YAAY,CAACN,KAAD,EAAQ;AAClB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACsD,aAAF,CAAgBD,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE4D,EAAAA,YAAY,CAACP,KAAD,EAAQ;AAClB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACuD,aAAF,CAAgBF,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE6D,EAAAA,YAAY,CAACR,KAAD,EAAQ;AAClB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACwD,aAAF,CAAgBH,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE8D,EAAAA,YAAY,CAACT,KAAD,EAAQ;AAClB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACyD,aAAF,CAAgBJ,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACE+D,EAAAA,YAAY,CAACV,KAAD,EAAQ;AAClB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAAC+D,YAAF,CAAeV,KAAf;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEgE,EAAAA,YAAY,CAACX,KAAD,EAAQ;AAClB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACgE,YAAF,CAAeX,KAAf;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEiE,EAAAA,aAAa,CAACZ,KAAD,EAAQ;AACnB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACiE,aAAF,CAAgBZ,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEkE,EAAAA,aAAa,CAACb,KAAD,EAAQ;AACnB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACkE,aAAF,CAAgBb,KAAhB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEmE,EAAAA,eAAe,CAACd,KAAD,EAAQ;AACrB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACmE,eAAF,CAAkBd,KAAlB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEoE,EAAAA,eAAe,CAACf,KAAD,EAAQ;AACrB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACoE,eAAF,CAAkBf,KAAlB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEqE,EAAAA,gBAAgB,CAAChB,KAAD,EAAQ;AACtB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACqE,gBAAF,CAAmBhB,KAAnB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEsE,EAAAA,gBAAgB,CAACjB,KAAD,EAAQ;AACtB,UAAMrD,CAAC,GAAGtD,MAAM,CAACoC,KAAP,CAAa,CAAb,CAAV;AACAkB,IAAAA,CAAC,CAACsE,gBAAF,CAAmBjB,KAAnB;AACA,WAAO,KAAKxD,IAAL,CAAUG,CAAV,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEuE,EAAAA,SAAS,GAAG;AACV,UAAMvE,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACuE,SAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,UAAMxE,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACwE,YAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,UAAMzE,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACyE,YAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,UAAM1E,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAAC0E,YAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,UAAM3E,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAAC2E,YAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,QAAQ,GAAG;AACT,UAAM5E,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAAC4E,QAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,GAAG;AACZ,UAAM7E,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAAC6E,WAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,GAAG;AACZ,UAAM9E,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAAC8E,WAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,GAAG;AACZ,UAAM/E,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAAC+E,WAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,GAAG;AACZ,UAAMhF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACgF,WAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,GAAG;AACZ,UAAMjF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACiF,WAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,WAAW,GAAG;AACZ,UAAMlF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACkF,WAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,UAAMnF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACmF,YAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,YAAY,GAAG;AACb,UAAMpF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACoF,YAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,cAAc,GAAG;AACf,UAAMrF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACqF,cAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,cAAc,GAAG;AACf,UAAMtF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACsF,cAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,eAAe,GAAG;AAChB,UAAMvF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACuF,eAAF,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,eAAe,GAAG;AAChB,UAAMxF,CAAC,GAAG,KAAKI,IAAL,CAAU,CAAV,CAAV;;AACA,QAAI,CAAC1D,MAAM,CAACa,QAAP,CAAgByC,CAAhB,CAAL,EAAyB;AACvB,aAAO,IAAP;AACD;;AACD,WAAOA,CAAC,CAACwF,eAAF,EAAP;AACD;;AA79BqC;;AAg+BxCC,MAAM,CAACC,OAAP,GAAiB3I,QAAjB","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst {Buffer} = require('buffer')\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null\n    let inpE = /** @type {BufferEncoding?} */ (null)\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n        } else if (input) {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid input')\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding\n        }\n        break\n      case 'string':\n        inpE = /** @type {BufferEncoding} */ (inputEncoding)\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid inputEncoding')\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options')\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe\n    delete options.watchPipe\n    const readError = Boolean(options.readError)\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode\n        // @ts-ignore: TS2339 (using internal interface)\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream'\n          )\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    }\n    return nf1.compare(nf2)\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null\n    let onFinish = null\n    let onError = null\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size))\n        return\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n        return\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size))\n        }\n      }\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n      }\n      onError = reject\n      this.on('readable', onReadable)\n      this.on('error', onError)\n      this.on('finish', onFinish)\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable)\n        this.removeListener('error', onError)\n        this.removeListener('finish', onFinish)\n      }\n    })\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', er => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    }\n\n    const buf1 = this.slice()\n    const buf2 = other.slice()\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2)\n    }\n    throw new Error('Cannot compare streams in object mode')\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default: {\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n      }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    }\n    return b\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if (!encoding || (encoding === 'utf8')) {\n      return td.decode(buf)\n    }\n    return buf.toString(encoding)\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string')\n      }\n      return JSON.stringify(b)\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt(`0x${b.toString('hex')}`)\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`)\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret -= mask\n    }\n    return ret\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt8()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16BE()\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32BE()\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt8()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16BE()\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32BE()\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatLE()\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatBE()\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleLE()\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleBE()\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64LE()\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64BE()\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64LE()\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64BE()\n  }\n}\n\nmodule.exports = NoFilter\n"]},"metadata":{},"sourceType":"script"}
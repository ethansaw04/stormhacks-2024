{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst utils = require('./utils');\n\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON');\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn;\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn);\n    }\n  } else if (obj && typeof obj === 'object') {\n    // FFS, complexity in the protocol.\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || obj.tag < 21 || obj.tag > 23) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn);\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this);\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this);\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex');\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab);\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64]\n  }[size];\n  const end = byteOffset + byteLength;\n\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true));\n  }\n}\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\n\n\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis;\n    } else {\n      setBuffersToJSON(v, b64urlThis);\n    }\n\n    return tag;\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this;\n    } else {\n      setBuffersToJSON(v, b64this);\n    }\n\n    return tag;\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis;\n    } else {\n      setBuffersToJSON(v, hexThis);\n    }\n\n    return tag;\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters');\n    }\n\n    const last = v.length % 4;\n\n    if (last === 1) {\n      throw new Error('Invalid base64url length');\n    } // -  the padding bits in a 2- or 3-character block are not 0, or\n\n\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n    // the string is invalid.\n\n\n    return tag;\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);\n\n    if (!m) {\n      throw new Error('Invalid base64 characters');\n    }\n\n    if (v.length % 4 !== 0) {\n      throw new Error('Invalid base64 length');\n    } // -  the padding bits in a 2- or 3-character block are not 0, or\n\n\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n\n\n    return tag;\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v)\n};\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array // 87: not implemented, float128 array\n\n}; // Safari\n\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array;\n  TYPED_ARRAY_TAGS[71] = BigUint64Array;\n}\n\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array;\n  TYPED_ARRAY_TAGS[79] = BigInt64Array;\n}\n\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer');\n  }\n\n  const {\n    tag\n  } = tagged; // See https://tools.ietf.org/html/rfc8746\n\n  const TypedClass = TYPED_ARRAY_TAGS[tag];\n\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`);\n  }\n\n  const little = tag & 0b00000100;\n  const float = (tag & 0b00010000) >> 4;\n  const sz = 2 ** (float + (tag & 0b00000011));\n\n  if (!little !== utils.isBigEndian() && sz > 1) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);\n  return new TypedClass(ab);\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray;\n}\n/**\n * @type {TagMap}\n * @private\n */\n\n\nlet current_TAGS = {};\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\n\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`);\n    }\n\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`);\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value);\n    }\n\n    const ret = {\n      tag: this.tag,\n      value: this.value\n    };\n\n    if (this.err) {\n      ret.err = this.err;\n    }\n\n    return ret;\n  }\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n\n\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n\n\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n\n    return gen.pushAny(this.value);\n  }\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n\n\n  convert(converters) {\n    let f = converters == null ? undefined : converters[this.tag];\n\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag];\n\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n\n    try {\n      return f.call(this, this.value, this);\n    } catch (error) {\n      if (error && error.message && error.message.length > 0) {\n        this.err = error.message;\n      } else {\n        this.err = error;\n      }\n\n      return this;\n    }\n  }\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n\n\n  static get TAGS() {\n    return current_TAGS;\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val;\n  }\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n\n\n  static reset() {\n    Tagged.TAGS = { ...TAGS\n    };\n  }\n\n}\n\nTagged.INTERNAL_JSON = INTERNAL_JSON;\nTagged.reset();\nmodule.exports = Tagged;","map":{"version":3,"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/cbor/lib/tagged.js"],"names":["constants","require","utils","INTERNAL_JSON","Symbol","setBuffersToJSON","obj","fn","isBufferish","toJSON","Array","isArray","v","Tagged","tag","Object","values","b64this","base64","b64urlThis","base64url","hexThis","toString","swapEndian","ab","size","byteOffset","byteLength","dv","DataView","getter","setter","getUint16","setUint16","getUint32","setUint32","getBigUint64","setBigUint64","end","offset","call","TAGS","Date","bufferToBigInt","BI","MINUS_ONE","URL","match","Error","last","length","indexOf","m","groups","padding","RegExp","Set","TYPED_ARRAY_TAGS","Uint8Array","Uint16Array","Uint32Array","Uint8ClampedArray","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","BigUint64Array","BigInt64Array","_toTypedArray","val","tagged","TypeError","TypedClass","little","float","sz","isBigEndian","buffer","slice","n","keys","current_TAGS","constructor","value","err","ret","JSON","stringify","encodeCBOR","gen","_pushTag","pushAny","convert","converters","f","undefined","error","message","reset","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst constants = require('./constants')\nconst utils = require('./utils')\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON')\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn)\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn)\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this)\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this)\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex')\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab)\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size]\n\n  const end = byteOffset + byteLength\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true))\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis\n    } else {\n      setBuffersToJSON(v, b64urlThis)\n    }\n    return tag\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this\n    } else {\n      setBuffersToJSON(v, b64this)\n    }\n    return tag\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis\n    } else {\n      setBuffersToJSON(v, hexThis)\n    }\n    return tag\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters')\n    }\n    const last = v.length % 4\n    if (last === 1) {\n      throw new Error('Invalid base64url length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/)\n    if (!m) {\n      throw new Error('Invalid base64 characters')\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n}\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n}\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array\n  TYPED_ARRAY_TAGS[71] = BigUint64Array\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array\n  TYPED_ARRAY_TAGS[79] = BigInt64Array\n}\n\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer')\n  }\n  const {tag} = tagged\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag]\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`)\n  }\n  const little = tag & 0b00000100\n  const float = (tag & 0b00010000) >> 4\n  const sz = 2 ** (float + (tag & 0b00000011))\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength)\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength)\n  return new TypedClass(ab)\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {}\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`)\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`)\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value)\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    }\n    if (this.err) {\n      ret.err = this.err\n    }\n    return ret\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag]\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(this, this.value, this)\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message\n      } else {\n        this.err = error\n      }\n      return this\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS}\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON\nTagged.reset()\nmodule.exports = Tagged\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst NoFilter = require('nofilter');\n\nconst stream = require('stream');\n\nconst constants = require('./constants');\n\nconst {\n  NUMBYTES,\n  SHIFT32,\n  BI,\n  SYMS\n} = constants;\nconst MAX_SAFE_HIGH = 0x1fffff;\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\n\nconst td = new TextDecoder('utf8', {\n  fatal: true,\n  ignoreBOM: true\n});\n\nexports.utf8 = buf => td.decode(buf);\n\nexports.utf8.checksUTF8 = true;\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true;\n  }\n\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function');\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b && typeof b === 'object' && (Buffer.isBuffer(b) || b instanceof Uint8Array || b instanceof Uint8ClampedArray || b instanceof ArrayBuffer || b instanceof DataView);\n};\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b;\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength);\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b);\n  }\n\n  return null;\n};\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0);\n\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0);\n\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0);\n\n    case NUMBYTES.EIGHT:\n      {\n        const f = buf.readUInt32BE(0);\n        const g = buf.readUInt32BE(4);\n\n        if (f > MAX_SAFE_HIGH) {\n          return BigInt(f) * BI.SHIFT32 + BigInt(g);\n        }\n\n        return f * SHIFT32 + g;\n      }\n\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`);\n  }\n};\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n  const u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  const u = u32.readUInt32BE(0); // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  } // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n\n  let s16 = u >> 16 & 0x8000; // Top bit is sign\n\n  const exp = u >> 23 & 0xff; // Then 5 bits of exponent\n\n  const mant = u & 0x7fffff; // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if (exp >= 113 && exp <= 142) {\n    s16 += (exp - 112 << 10) + (mant >> 13);\n  } else if (exp >= 103 && exp < 113) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n    if (mant & (1 << 126 - exp) - 1) {\n      return false;\n    }\n\n    s16 += mant + 0x800000 >> 126 - exp;\n  } else {\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n    // hildjj: Infinity already handled\n    //   } else\n    //     goto float32;           /* loss of range */\n    return false;\n  } // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n\n\n  buf.writeUInt16BE(s16);\n  return true;\n};\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1;\n  const exp = (buf[0] & 0x7C) >> 2;\n  const mant = (buf[0] & 0x03) << 8 | buf[1];\n\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity);\n  }\n\n  return sign * 2 ** (exp - 25) * (1024 + mant);\n};\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf);\n\n    case 4:\n      return buf.readFloatBE(0);\n\n    case 8:\n      return buf.readDoubleBE(0);\n\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`);\n  }\n};\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex');\n};\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '');\n  let start = 0;\n  let end = s.length % 8 || 8;\n  const chunks = [];\n\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2));\n    start = end;\n    end += 8;\n  }\n\n  return Buffer.from(chunks);\n};\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  return a.length === b.length && a.every((elem, i) => elem === b[i]);\n};\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`);\n};\n\nexports.cborValueToString = function cborValueToString(val) {\n  let float_bytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n  switch (typeof val) {\n    case 'symbol':\n      {\n        switch (val) {\n          case SYMS.NULL:\n            return 'null';\n\n          case SYMS.UNDEFINED:\n            return 'undefined';\n\n          case SYMS.BREAK:\n            return 'BREAK';\n        } // Impossible in node 10\n\n        /* istanbul ignore if */\n\n\n        if (val.description) {\n          return val.description;\n        } // On node10, Symbol doesn't have description.  Parse it out of the\n        // toString value, which looks like `Symbol(foo)`.\n\n\n        const s = val.toString();\n        const m = s.match(/^Symbol\\((?<name>.*)\\)/);\n        /* istanbul ignore if */\n\n        if (m && m.groups.name) {\n          // Impossible in node 12+\n\n          /* istanbul ignore next */\n          return m.groups.name;\n        }\n\n        return 'Symbol';\n      }\n\n    case 'string':\n      return JSON.stringify(val);\n\n    case 'bigint':\n      return val.toString();\n\n    case 'number':\n      {\n        const s = Object.is(val, -0) ? '-0' : String(val);\n        return float_bytes > 0 ? `${s}_${float_bytes}` : s;\n      }\n\n    case 'object':\n      {\n        // A null should be caught above\n        const buf = exports.bufferishToBuffer(val);\n\n        if (buf) {\n          const hex = buf.toString('hex');\n          return float_bytes === -Infinity ? hex : `h'${hex}'`;\n        }\n\n        if (typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n          return val[Symbol.for('nodejs.util.inspect.custom')]();\n        } // Shouldn't get non-empty arrays here\n\n\n        if (Array.isArray(val)) {\n          return '[]';\n        } // This should be all that is left\n\n\n        return '{}';\n      }\n  }\n\n  return String(val);\n};\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, encoding == null ? 'hex' : encoding);\n  }\n\n  const buf = exports.bufferishToBuffer(input);\n\n  if (buf) {\n    return new NoFilter(buf);\n  }\n\n  if (isReadable(input)) {\n    return input;\n  }\n\n  throw new Error('Unknown input type');\n};\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_'\n};\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\n\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64').replace(/[=+/]/g, c => B64URL_SWAPS[c]);\n};\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\n\n\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64');\n};\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !((view[0] = 1) & array[0]);\n};","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/cbor/lib/utils.js"],"names":["Buffer","require","NoFilter","stream","constants","NUMBYTES","SHIFT32","BI","SYMS","MAX_SAFE_HIGH","td","TextDecoder","fatal","ignoreBOM","exports","utf8","buf","decode","checksUTF8","isReadable","s","Readable","every","f","isBufferish","b","isBuffer","Uint8Array","Uint8ClampedArray","ArrayBuffer","DataView","bufferishToBuffer","isView","from","buffer","byteOffset","byteLength","parseCBORint","ai","ONE","readUInt8","TWO","readUInt16BE","FOUR","readUInt32BE","EIGHT","g","BigInt","Error","writeHalf","half","u32","allocUnsafe","writeFloatBE","u","s16","exp","mant","writeUInt16BE","parseHalf","sign","NaN","Infinity","parseCBORfloat","length","readFloatBE","readDoubleBE","hex","replace","bin","start","end","chunks","push","parseInt","slice","arrayEqual","a","elem","i","bufferToBigInt","toString","cborValueToString","val","float_bytes","NULL","UNDEFINED","BREAK","description","m","match","groups","name","JSON","stringify","Object","is","String","Symbol","for","Array","isArray","guessEncoding","input","encoding","B64URL_SWAPS","base64url","c","base64","isBigEndian","array","view","Uint32Array"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {Buffer} = require('buffer')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {NUMBYTES, SHIFT32, BI, SYMS} = constants\nconst MAX_SAFE_HIGH = 0x1fffff\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\nexports.utf8 = buf => td.decode(buf)\nexports.utf8.checksUTF8 = true\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true\n  }\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function')\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b &&\n    (typeof b === 'object') &&\n    ((Buffer.isBuffer(b)) ||\n      (b instanceof Uint8Array) ||\n      (b instanceof Uint8ClampedArray) ||\n      (b instanceof ArrayBuffer) ||\n      (b instanceof DataView))\n}\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength)\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b)\n  }\n  return null\n}\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0)\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0)\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0)\n    case NUMBYTES.EIGHT: {\n      const f = buf.readUInt32BE(0)\n      const g = buf.readUInt32BE(4)\n      if (f > MAX_SAFE_HIGH) {\n        return (BigInt(f) * BI.SHIFT32) + BigInt(g)\n      }\n      return (f * SHIFT32) + g\n    }\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`)\n  }\n}\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000 // Top bit is sign\n  const exp = (u >> 23) & 0xff // Then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n  } else if ((exp >= 103) && (exp < 113)) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false\n  }\n\n  // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16)\n  return true\n}\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1\n  const exp = (buf[0] & 0x7C) >> 2\n  const mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity)\n  }\n  return sign * (2 ** (exp - 25)) * (1024 + mant)\n}\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf)\n    case 4:\n      return buf.readFloatBE(0)\n    case 8:\n      return buf.readDoubleBE(0)\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`)\n  }\n}\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex')\n}\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '')\n  let start = 0\n  let end = (s.length % 8) || 8\n  const chunks = []\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2))\n    start = end\n    end += 8\n  }\n  return Buffer.from(chunks)\n}\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i])\n}\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`)\n}\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol': {\n      switch (val) {\n        case SYMS.NULL:\n          return 'null'\n        case SYMS.UNDEFINED:\n          return 'undefined'\n        case SYMS.BREAK:\n          return 'BREAK'\n      }\n      // Impossible in node 10\n      /* istanbul ignore if */\n      if (val.description) {\n        return val.description\n      }\n      // On node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n      const s = val.toString()\n      const m = s.match(/^Symbol\\((?<name>.*)\\)/)\n      /* istanbul ignore if */\n      if (m && m.groups.name) {\n        // Impossible in node 12+\n        /* istanbul ignore next */\n        return m.groups.name\n      }\n      return 'Symbol'\n    }\n    case 'string':\n      return JSON.stringify(val)\n    case 'bigint':\n      return val.toString()\n    case 'number': {\n      const s = Object.is(val, -0) ? '-0' : String(val)\n      return (float_bytes > 0) ? `${s}_${float_bytes}` : s\n    }\n    case 'object': {\n      // A null should be caught above\n      const buf = exports.bufferishToBuffer(val)\n      if (buf) {\n        const hex = buf.toString('hex')\n        return (float_bytes === -Infinity) ? hex : `h'${hex}'`\n      }\n      if (typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n        return val[Symbol.for('nodejs.util.inspect.custom')]()\n      }\n      // Shouldn't get non-empty arrays here\n      if (Array.isArray(val)) {\n        return '[]'\n      }\n      // This should be all that is left\n      return '{}'\n    }\n  }\n  return String(val)\n}\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, (encoding == null) ? 'hex' : encoding)\n  }\n  const buf = exports.bufferishToBuffer(input)\n  if (buf) {\n    return new NoFilter(buf)\n  }\n  if (isReadable(input)) {\n    return input\n  }\n  throw new Error('Unknown input type')\n}\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_',\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf)\n    .toString('base64')\n    .replace(/[=+/]/g, c => B64URL_SWAPS[c])\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64')\n}\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4)\n  const view = new Uint32Array(array.buffer)\n  return !((view[0] = 1) & array[0])\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// **Github:** https://github.com/fidm/asn1\n//\n// **License:** MIT\nconst util_1 = require(\"util\");\nconst pemLineLength = 64;\nconst pemStart = '-----BEGIN ';\nconst pemEnd = '-----END ';\nconst pemEndOfLine = '-----';\nconst procType = 'Proc-Type';\n/**\n * Implements the PEM data encoding, which originated in Privacy\n * Enhanced Mail. The most common use of PEM encoding today is in TLS keys and\n * certificates. See RFC 1421.\n *\n * A PEM represents a PEM encoded structure.\n *\n * The encoded form is:\n * ```\n * -----BEGIN Type-----\n * Headers\n * base64-encoded Bytes\n * -----END Type-----\n * ```\n *\n * Headers like:\n * ```\n * Proc-Type: 4,ENCRYPTED\n * DEK-Info: DES-EDE3-CBC,29DE8F99F382D122\n * ```\n */\nclass PEM {\n  /**\n   * Parse PEM formatted buffer, returns one or more PEM object.\n   * If there is no PEM object, it will throw error.\n   * @param data buffer to parse.\n   */\n  static parse(data) {\n    const res = [];\n    const lines = data.toString('utf8').split('\\n').map(s => s.trim()).filter(s => s !== '' && !s.startsWith('#'));\n    while (lines.length > 0) {\n      res.push(parse(lines));\n    }\n    if (res.length === 0) {\n      throw new Error('PEM: no block');\n    }\n    return res;\n  }\n  constructor(type, body) {\n    this.type = type;\n    this.body = body;\n    this.headers = Object.create(null);\n  }\n  /**\n   * Return exists Proc-Type header or empty string\n   */\n  get procType() {\n    return this.getHeader(procType);\n  }\n  /**\n   * Return a header or empty string with given key.\n   */\n  getHeader(key) {\n    const val = this.headers[key];\n    return val == null ? '' : val;\n  }\n  /**\n   * Set a header with given key/value.\n   */\n  setHeader(key, val) {\n    if (key.includes(':')) {\n      throw new Error('pem: cannot encode a header key that contains a colon');\n    }\n    if (key === '' || val === '') {\n      throw new Error('pem: invalid header key or value');\n    }\n    this.headers[key] = val;\n  }\n  /**\n   * Encode to PEM formatted string.\n   */\n  toString() {\n    let rVal = pemStart + this.type + pemEndOfLine + '\\n';\n    const headers = Object.keys(this.headers);\n    if (headers.length > 0) {\n      // The Proc-Type header must be written first. See RFC 1421, section 4.6.1.1\n      const type = this.procType;\n      if (type !== '') {\n        rVal += `${procType}: ${type}\\n`;\n      }\n      // For consistency of output, write other headers sorted by key.\n      headers.sort();\n      for (const key of headers) {\n        if (key !== procType) {\n          rVal += `${key}: ${this.headers[key]}\\n`;\n        }\n      }\n      rVal += '\\n';\n    }\n    const body = this.body.toString('base64');\n    let offset = 0;\n    while (offset < body.length) {\n      rVal += body.slice(offset, offset + pemLineLength) + '\\n';\n      offset += pemLineLength;\n    }\n    rVal += pemEnd + this.type + pemEndOfLine + '\\n';\n    return rVal;\n  }\n  /**\n   * Encode to PEM formatted buffer.\n   */\n  toBuffer() {\n    return Buffer.from(this.toString(), 'utf8');\n  }\n  /**\n   * Returns the body.\n   */\n  valueOf() {\n    return this.body;\n  }\n  /**\n   * Return a friendly JSON object for debuging.\n   */\n  toJSON() {\n    return {\n      type: this.type,\n      body: this.body,\n      headers: this.headers\n    };\n  }\n  [util_1.inspect.custom](_depth, options) {\n    return `<${this.constructor.name} ${util_1.inspect(this.toJSON(), options)}>`;\n  }\n}\nexports.PEM = PEM;\nfunction parse(lines) {\n  let line = lines.shift();\n  if (line == null || !line.startsWith(pemStart) || !line.endsWith(pemEndOfLine)) {\n    throw new Error('pem: invalid BEGIN line');\n  }\n  const type = line.slice(pemStart.length, line.length - pemEndOfLine.length);\n  if (type === '') {\n    throw new Error('pem: invalid type');\n  }\n  const headers = [];\n  line = lines.shift();\n  while (line != null && line.includes(': ')) {\n    const header = line.split(': ');\n    if (header.length !== 2 || header[0] === '' || header[1] === '') {\n      throw new Error('pem: invalid Header line');\n    }\n    headers.push(header);\n    line = lines.shift();\n  }\n  let body = '';\n  while (line != null && !line.startsWith(pemEnd)) {\n    body += line;\n    line = lines.shift();\n  }\n  if (line == null || line !== `${pemEnd}${type}${pemEndOfLine}`) {\n    throw new Error('pem: invalid END line');\n  }\n  const pem = new PEM(type, Buffer.from(body, 'base64'));\n  if (body === '' || pem.body.toString('base64') !== body) {\n    throw new Error('pem: invalid base64 body');\n  }\n  for (const header of headers) {\n    pem.setHeader(header[0], header[1]);\n  }\n  return pem;\n}","map":{"version":3,"names":["util_1","require","pemLineLength","pemStart","pemEnd","pemEndOfLine","procType","PEM","parse","data","res","lines","toString","split","map","s","trim","filter","startsWith","length","push","Error","constructor","type","body","headers","Object","create","getHeader","key","val","setHeader","includes","rVal","keys","sort","offset","slice","toBuffer","Buffer","from","valueOf","toJSON","inspect","custom","_depth","options","name","exports","line","shift","endsWith","header","pem"],"sources":["../src/pem.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}
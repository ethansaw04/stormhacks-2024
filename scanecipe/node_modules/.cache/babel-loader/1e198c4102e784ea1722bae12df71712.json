{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // **Github:** https://github.com/fidm/asn1\n//\n// **License:** MIT\n\nconst util_1 = require(\"util\");\n\nconst pemLineLength = 64;\nconst pemStart = '-----BEGIN ';\nconst pemEnd = '-----END ';\nconst pemEndOfLine = '-----';\nconst procType = 'Proc-Type';\n/**\n * Implements the PEM data encoding, which originated in Privacy\n * Enhanced Mail. The most common use of PEM encoding today is in TLS keys and\n * certificates. See RFC 1421.\n *\n * A PEM represents a PEM encoded structure.\n *\n * The encoded form is:\n * ```\n * -----BEGIN Type-----\n * Headers\n * base64-encoded Bytes\n * -----END Type-----\n * ```\n *\n * Headers like:\n * ```\n * Proc-Type: 4,ENCRYPTED\n * DEK-Info: DES-EDE3-CBC,29DE8F99F382D122\n * ```\n */\n\nclass PEM {\n  /**\n   * Parse PEM formatted buffer, returns one or more PEM object.\n   * If there is no PEM object, it will throw error.\n   * @param data buffer to parse.\n   */\n  static parse(data) {\n    const res = [];\n    const lines = data.toString('utf8').split('\\n').map(s => s.trim()).filter(s => s !== '' && !s.startsWith('#'));\n\n    while (lines.length > 0) {\n      res.push(parse(lines));\n    }\n\n    if (res.length === 0) {\n      throw new Error('PEM: no block');\n    }\n\n    return res;\n  }\n\n  constructor(type, body) {\n    this.type = type;\n    this.body = body;\n    this.headers = Object.create(null);\n  }\n  /**\n   * Return exists Proc-Type header or empty string\n   */\n\n\n  get procType() {\n    return this.getHeader(procType);\n  }\n  /**\n   * Return a header or empty string with given key.\n   */\n\n\n  getHeader(key) {\n    const val = this.headers[key];\n    return val == null ? '' : val;\n  }\n  /**\n   * Set a header with given key/value.\n   */\n\n\n  setHeader(key, val) {\n    if (key.includes(':')) {\n      throw new Error('pem: cannot encode a header key that contains a colon');\n    }\n\n    if (key === '' || val === '') {\n      throw new Error('pem: invalid header key or value');\n    }\n\n    this.headers[key] = val;\n  }\n  /**\n   * Encode to PEM formatted string.\n   */\n\n\n  toString() {\n    let rVal = pemStart + this.type + pemEndOfLine + '\\n';\n    const headers = Object.keys(this.headers);\n\n    if (headers.length > 0) {\n      // The Proc-Type header must be written first. See RFC 1421, section 4.6.1.1\n      const type = this.procType;\n\n      if (type !== '') {\n        rVal += `${procType}: ${type}\\n`;\n      } // For consistency of output, write other headers sorted by key.\n\n\n      headers.sort();\n\n      for (const key of headers) {\n        if (key !== procType) {\n          rVal += `${key}: ${this.headers[key]}\\n`;\n        }\n      }\n\n      rVal += '\\n';\n    }\n\n    const body = this.body.toString('base64');\n    let offset = 0;\n\n    while (offset < body.length) {\n      rVal += body.slice(offset, offset + pemLineLength) + '\\n';\n      offset += pemLineLength;\n    }\n\n    rVal += pemEnd + this.type + pemEndOfLine + '\\n';\n    return rVal;\n  }\n  /**\n   * Encode to PEM formatted buffer.\n   */\n\n\n  toBuffer() {\n    return Buffer.from(this.toString(), 'utf8');\n  }\n  /**\n   * Returns the body.\n   */\n\n\n  valueOf() {\n    return this.body;\n  }\n  /**\n   * Return a friendly JSON object for debuging.\n   */\n\n\n  toJSON() {\n    return {\n      type: this.type,\n      body: this.body,\n      headers: this.headers\n    };\n  }\n\n  [util_1.inspect.custom](_depth, options) {\n    return `<${this.constructor.name} ${util_1.inspect(this.toJSON(), options)}>`;\n  }\n\n}\n\nexports.PEM = PEM;\n\nfunction parse(lines) {\n  let line = lines.shift();\n\n  if (line == null || !line.startsWith(pemStart) || !line.endsWith(pemEndOfLine)) {\n    throw new Error('pem: invalid BEGIN line');\n  }\n\n  const type = line.slice(pemStart.length, line.length - pemEndOfLine.length);\n\n  if (type === '') {\n    throw new Error('pem: invalid type');\n  }\n\n  const headers = [];\n  line = lines.shift();\n\n  while (line != null && line.includes(': ')) {\n    const header = line.split(': ');\n\n    if (header.length !== 2 || header[0] === '' || header[1] === '') {\n      throw new Error('pem: invalid Header line');\n    }\n\n    headers.push(header);\n    line = lines.shift();\n  }\n\n  let body = '';\n\n  while (line != null && !line.startsWith(pemEnd)) {\n    body += line;\n    line = lines.shift();\n  }\n\n  if (line == null || line !== `${pemEnd}${type}${pemEndOfLine}`) {\n    throw new Error('pem: invalid END line');\n  }\n\n  const pem = new PEM(type, Buffer.from(body, 'base64'));\n\n  if (body === '' || pem.body.toString('base64') !== body) {\n    throw new Error('pem: invalid base64 body');\n  }\n\n  for (const header of headers) {\n    pem.setHeader(header[0], header[1]);\n  }\n\n  return pem;\n}","map":{"version":3,"sources":["../src/pem.ts"],"names":[],"mappings":"AAAA;;;;IACA;AACA;AACA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AAEA,MAAM,aAAa,GAAG,EAAtB;AACA,MAAM,QAAQ,GAAG,aAAjB;AACA,MAAM,MAAM,GAAG,WAAf;AACA,MAAM,YAAY,GAAG,OAArB;AACA,MAAM,QAAQ,GAAG,WAAjB;AAEA;;;;;;;;;;;;;;;;;;;;AAoBG;;AAEH,MAAa,GAAb,CAAgB;AACd;;;;AAIG;AACS,SAAL,KAAK,CAAE,IAAF,EAAc;AACxB,UAAM,GAAG,GAAG,EAAZ;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,QAAL,CAAc,MAAd,EAAsB,KAAtB,CAA4B,IAA5B,EACX,GADW,CACN,CAAD,IAAO,CAAC,CAAC,IAAF,EADA,EAEX,MAFW,CAEH,CAAD,IAAO,CAAC,KAAK,EAAN,IAAY,CAAC,CAAC,CAAC,UAAF,CAAa,GAAb,CAFhB,CAAd;;AAGA,WAAO,KAAK,CAAC,MAAN,GAAe,CAAtB,EAAyB;AACvB,MAAA,GAAG,CAAC,IAAJ,CAAS,KAAK,CAAC,KAAD,CAAd;AACD;;AACD,QAAI,GAAG,CAAC,MAAJ,KAAe,CAAnB,EAAsB;AACpB,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,WAAO,GAAP;AACD;;AAYD,EAAA,WAAA,CAAa,IAAb,EAA2B,IAA3B,EAAuC;AACrC,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,OAAL,GAAe,MAAM,CAAC,MAAP,CAAc,IAAd,CAAf;AACD;AAED;;AAEG;;;AACS,MAAR,QAAQ,GAAA;AACV,WAAO,KAAK,SAAL,CAAe,QAAf,CAAP;AACD;AAED;;AAEG;;;AACH,EAAA,SAAS,CAAE,GAAF,EAAa;AACpB,UAAM,GAAG,GAAG,KAAK,OAAL,CAAa,GAAb,CAAZ;AACA,WAAO,GAAG,IAAI,IAAP,GAAc,EAAd,GAAmB,GAA1B;AACD;AAED;;AAEG;;;AACH,EAAA,SAAS,CAAE,GAAF,EAAe,GAAf,EAA0B;AACjC,QAAI,GAAG,CAAC,QAAJ,CAAa,GAAb,CAAJ,EAAuB;AACrB,YAAM,IAAI,KAAJ,CAAU,uDAAV,CAAN;AACD;;AACD,QAAI,GAAG,KAAK,EAAR,IAAc,GAAG,KAAK,EAA1B,EAA8B;AAC5B,YAAM,IAAI,KAAJ,CAAU,kCAAV,CAAN;AACD;;AACD,SAAK,OAAL,CAAa,GAAb,IAAoB,GAApB;AACD;AAED;;AAEG;;;AACH,EAAA,QAAQ,GAAA;AACN,QAAI,IAAI,GAAG,QAAQ,GAAG,KAAK,IAAhB,GAAuB,YAAvB,GAAsC,IAAjD;AACA,UAAM,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,OAAjB,CAAhB;;AACA,QAAI,OAAO,CAAC,MAAR,GAAiB,CAArB,EAAwB;AACtB;AACA,YAAM,IAAI,GAAG,KAAK,QAAlB;;AACA,UAAI,IAAI,KAAK,EAAb,EAAiB;AACf,QAAA,IAAI,IAAI,GAAG,QAAQ,KAAK,IAAI,IAA5B;AACD,OALqB,CAMtB;;;AACA,MAAA,OAAO,CAAC,IAAR;;AACA,WAAK,MAAM,GAAX,IAAkB,OAAlB,EAA2B;AACzB,YAAI,GAAG,KAAK,QAAZ,EAAsB;AACpB,UAAA,IAAI,IAAI,GAAG,GAAG,KAAK,KAAK,OAAL,CAAa,GAAb,CAAiB,IAApC;AACD;AACF;;AACD,MAAA,IAAI,IAAI,IAAR;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,IAAL,CAAU,QAAV,CAAmB,QAAnB,CAAb;AACA,QAAI,MAAM,GAAG,CAAb;;AACA,WAAO,MAAM,GAAG,IAAI,CAAC,MAArB,EAA6B;AAC3B,MAAA,IAAI,IAAI,IAAI,CAAC,KAAL,CAAW,MAAX,EAAmB,MAAM,GAAG,aAA5B,IAA6C,IAArD;AACA,MAAA,MAAM,IAAI,aAAV;AACD;;AAED,IAAA,IAAI,IAAI,MAAM,GAAG,KAAK,IAAd,GAAqB,YAArB,GAAoC,IAA5C;AACA,WAAO,IAAP;AACD;AAED;;AAEG;;;AACH,EAAA,QAAQ,GAAA;AACN,WAAO,MAAM,CAAC,IAAP,CAAY,KAAK,QAAL,EAAZ,EAA6B,MAA7B,CAAP;AACD;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,IAAZ;AACD;AAED;;AAEG;;;AACH,EAAA,MAAM,GAAA;AACJ,WAAO;AACL,MAAA,IAAI,EAAE,KAAK,IADN;AAEL,MAAA,IAAI,EAAE,KAAK,IAFN;AAGL,MAAA,OAAO,EAAE,KAAK;AAHT,KAAP;AAKD;;AAEwB,GAAd,MAAA,CAAA,OAAA,CAAQ,MAAM,EAAG,MAAH,EAAgB,OAAhB,EAA4B;AACnD,WAAO,IAAI,KAAK,WAAL,CAAiB,IAAI,IAAI,MAAA,CAAA,OAAA,CAAQ,KAAK,MAAL,EAAR,EAAuB,OAAvB,CAA+B,GAAnE;AACD;;AA5Ha;;AAAhB,OAAA,CAAA,GAAA,GAAA,GAAA;;AA+HA,SAAS,KAAT,CAAgB,KAAhB,EAA+B;AAC7B,MAAI,IAAI,GAAG,KAAK,CAAC,KAAN,EAAX;;AACA,MAAI,IAAI,IAAI,IAAR,IAAgB,CAAC,IAAI,CAAC,UAAL,CAAgB,QAAhB,CAAjB,IAA8C,CAAC,IAAI,CAAC,QAAL,CAAc,YAAd,CAAnD,EAAgF;AAC9E,UAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,QAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,MAApB,EAA4B,IAAI,CAAC,MAAL,GAAc,YAAY,CAAC,MAAvD,CAAb;;AACA,MAAI,IAAI,KAAK,EAAb,EAAiB;AACf,UAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD;;AAED,QAAM,OAAO,GAA4B,EAAzC;AACA,EAAA,IAAI,GAAG,KAAK,CAAC,KAAN,EAAP;;AACA,SAAO,IAAI,IAAI,IAAR,IAAgB,IAAI,CAAC,QAAL,CAAc,IAAd,CAAvB,EAA4C;AAC1C,UAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAf;;AACA,QAAI,MAAM,CAAC,MAAP,KAAkB,CAAlB,IAAuB,MAAM,CAAC,CAAD,CAAN,KAAc,EAArC,IAA2C,MAAM,CAAC,CAAD,CAAN,KAAc,EAA7D,EAAiE;AAC/D,YAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACD;;AACD,IAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACA,IAAA,IAAI,GAAG,KAAK,CAAC,KAAN,EAAP;AACD;;AAED,MAAI,IAAI,GAAG,EAAX;;AACA,SAAO,IAAI,IAAI,IAAR,IAAgB,CAAC,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAxB,EAAiD;AAC/C,IAAA,IAAI,IAAI,IAAR;AACA,IAAA,IAAI,GAAG,KAAK,CAAC,KAAN,EAAP;AACD;;AACD,MAAI,IAAI,IAAI,IAAR,IAAgB,IAAI,KAAK,GAAG,MAAM,GAAG,IAAI,GAAG,YAAY,EAA5D,EAAgE;AAC9D,UAAM,IAAI,KAAJ,CAAU,uBAAV,CAAN;AACD;;AAED,QAAM,GAAG,GAAG,IAAI,GAAJ,CAAQ,IAAR,EAAc,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAAd,CAAZ;;AACA,MAAI,IAAI,KAAK,EAAT,IAAe,GAAG,CAAC,IAAJ,CAAS,QAAT,CAAkB,QAAlB,MAAgC,IAAnD,EAAyD;AACvD,UAAM,IAAI,KAAJ,CAAU,0BAAV,CAAN;AACD;;AACD,OAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC5B,IAAA,GAAG,CAAC,SAAJ,CAAc,MAAM,CAAC,CAAD,CAApB,EAAyB,MAAM,CAAC,CAAD,CAA/B;AACD;;AACD,SAAO,GAAP;AACD","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// **Github:** https://github.com/fidm/asn1\n//\n// **License:** MIT\nconst util_1 = require(\"util\");\nconst pemLineLength = 64;\nconst pemStart = '-----BEGIN ';\nconst pemEnd = '-----END ';\nconst pemEndOfLine = '-----';\nconst procType = 'Proc-Type';\n/**\n * Implements the PEM data encoding, which originated in Privacy\n * Enhanced Mail. The most common use of PEM encoding today is in TLS keys and\n * certificates. See RFC 1421.\n *\n * A PEM represents a PEM encoded structure.\n *\n * The encoded form is:\n * ```\n * -----BEGIN Type-----\n * Headers\n * base64-encoded Bytes\n * -----END Type-----\n * ```\n *\n * Headers like:\n * ```\n * Proc-Type: 4,ENCRYPTED\n * DEK-Info: DES-EDE3-CBC,29DE8F99F382D122\n * ```\n */\nclass PEM {\n    /**\n     * Parse PEM formatted buffer, returns one or more PEM object.\n     * If there is no PEM object, it will throw error.\n     * @param data buffer to parse.\n     */\n    static parse(data) {\n        const res = [];\n        const lines = data.toString('utf8').split('\\n')\n            .map((s) => s.trim())\n            .filter((s) => s !== '' && !s.startsWith('#'));\n        while (lines.length > 0) {\n            res.push(parse(lines));\n        }\n        if (res.length === 0) {\n            throw new Error('PEM: no block');\n        }\n        return res;\n    }\n    constructor(type, body) {\n        this.type = type;\n        this.body = body;\n        this.headers = Object.create(null);\n    }\n    /**\n     * Return exists Proc-Type header or empty string\n     */\n    get procType() {\n        return this.getHeader(procType);\n    }\n    /**\n     * Return a header or empty string with given key.\n     */\n    getHeader(key) {\n        const val = this.headers[key];\n        return val == null ? '' : val;\n    }\n    /**\n     * Set a header with given key/value.\n     */\n    setHeader(key, val) {\n        if (key.includes(':')) {\n            throw new Error('pem: cannot encode a header key that contains a colon');\n        }\n        if (key === '' || val === '') {\n            throw new Error('pem: invalid header key or value');\n        }\n        this.headers[key] = val;\n    }\n    /**\n     * Encode to PEM formatted string.\n     */\n    toString() {\n        let rVal = pemStart + this.type + pemEndOfLine + '\\n';\n        const headers = Object.keys(this.headers);\n        if (headers.length > 0) {\n            // The Proc-Type header must be written first. See RFC 1421, section 4.6.1.1\n            const type = this.procType;\n            if (type !== '') {\n                rVal += `${procType}: ${type}\\n`;\n            }\n            // For consistency of output, write other headers sorted by key.\n            headers.sort();\n            for (const key of headers) {\n                if (key !== procType) {\n                    rVal += `${key}: ${this.headers[key]}\\n`;\n                }\n            }\n            rVal += '\\n';\n        }\n        const body = this.body.toString('base64');\n        let offset = 0;\n        while (offset < body.length) {\n            rVal += body.slice(offset, offset + pemLineLength) + '\\n';\n            offset += pemLineLength;\n        }\n        rVal += pemEnd + this.type + pemEndOfLine + '\\n';\n        return rVal;\n    }\n    /**\n     * Encode to PEM formatted buffer.\n     */\n    toBuffer() {\n        return Buffer.from(this.toString(), 'utf8');\n    }\n    /**\n     * Returns the body.\n     */\n    valueOf() {\n        return this.body;\n    }\n    /**\n     * Return a friendly JSON object for debuging.\n     */\n    toJSON() {\n        return {\n            type: this.type,\n            body: this.body,\n            headers: this.headers,\n        };\n    }\n    [util_1.inspect.custom](_depth, options) {\n        return `<${this.constructor.name} ${util_1.inspect(this.toJSON(), options)}>`;\n    }\n}\nexports.PEM = PEM;\nfunction parse(lines) {\n    let line = lines.shift();\n    if (line == null || !line.startsWith(pemStart) || !line.endsWith(pemEndOfLine)) {\n        throw new Error('pem: invalid BEGIN line');\n    }\n    const type = line.slice(pemStart.length, line.length - pemEndOfLine.length);\n    if (type === '') {\n        throw new Error('pem: invalid type');\n    }\n    const headers = [];\n    line = lines.shift();\n    while (line != null && line.includes(': ')) {\n        const header = line.split(': ');\n        if (header.length !== 2 || header[0] === '' || header[1] === '') {\n            throw new Error('pem: invalid Header line');\n        }\n        headers.push(header);\n        line = lines.shift();\n    }\n    let body = '';\n    while (line != null && !line.startsWith(pemEnd)) {\n        body += line;\n        line = lines.shift();\n    }\n    if (line == null || line !== `${pemEnd}${type}${pemEndOfLine}`) {\n        throw new Error('pem: invalid END line');\n    }\n    const pem = new PEM(type, Buffer.from(body, 'base64'));\n    if (body === '' || pem.body.toString('base64') !== body) {\n        throw new Error('pem: invalid base64 body');\n    }\n    for (const header of headers) {\n        pem.setHeader(header[0], header[1]);\n    }\n    return pem;\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"// Needs to import only the sign and verify functions, not the encrypt and decrypt due to additional dependencies. \nimport * as cose from './cose-js/sign.js';\nimport { createHash as rawHash } from \"sha256-uint8array\";\nimport zlib from 'pako';\nimport * as cbor from 'cbor';\nimport * as base64 from 'base64-js';\nimport base45 from 'base45';\nimport { resolveKey, addCachedCerts, addCachedKeys } from './resolver';\nimport { getJWTFromPEM, getDERFromPEM } from './key-parser';\nconst URI_SCHEMA = 'HC1';\nconst CWT_ISSUER = 1;\nconst CWT_SUBJECT = 2;\nconst CWT_AUDIENCE = 3;\nconst CWT_EXPIRATION = 4;\nconst CWT_NOT_BEFORE = 5;\nconst CWT_ISSUED_AT = 6;\nconst CWT_ID = 7;\nconst CWT_HCERT = -260;\nconst CWT_HCERT_V1 = 1;\nconst CWT_STRING_PAYLOAD = 99;\nconst COSE_ALG_TAG = 1;\nconst COSE_KID_TAG = 4;\nconst NOT_SUPPORTED = \"not_supported\"; // QR Standard not supported by this algorithm\n\nconst INVALID_ENCODING = \"invalid_encoding\"; // could not decode Base45 for DCC, Base10 for SHC\n\nconst INVALID_COMPRESSION = \"invalid_compression\"; // could not decompress the byte array\n\nconst INVALID_SIGNING_FORMAT = \"invalid_signing_format\"; // invalid COSE, JOSE, W3C VC Payload\n\nconst KID_NOT_INCLUDED = \"kid_not_included\"; // unable to resolve the issuer ID\n\nconst ISSUER_NOT_TRUSTED = \"issuer_not_trusted\"; // issuer is not found in the registry\n\nconst TERMINATED_KEYS = \"terminated_keys\"; // issuer was terminated by the registry\n\nconst EXPIRED_KEYS = \"expired_keys\"; // keys expired\n\nconst REVOKED_KEYS = \"revoked_keys\"; // keys were revoked by the issuer\n\nconst INVALID_SIGNATURE = \"invalid_signature\"; // signature doesn't match\n\nconst VERIFIED = \"verified\"; // Verified content.\n\nfunction getKeyIDFromPEM(pem) {\n  return rawHash().update(getDERFromPEM(pem)).digest().slice(0, 8);\n}\n\nexport async function sign(payload, publicKeyPem, privateKeyP8) {\n  const jwt = getJWTFromPEM(publicKeyPem);\n  const keyId = getKeyIDFromPEM(publicKeyPem);\n  const headers = {\n    'p': {\n      'alg': jwt.alg,\n      'kid': keyId\n    },\n    'u': {}\n  };\n  const signer = {\n    'key': {\n      'pkcs8': getDERFromPEM(privateKeyP8)\n    }\n  };\n  const cborPayload = cbor.encode(payload);\n  return cose.create(headers, cborPayload, signer);\n}\n/*\n * I am not sure if I should build this by hand. \n */\n\nexport async function makeCWT(payload, monthsToExpire, issuer) {\n  let cwt = new Map();\n  let iss = new Date();\n  cwt.set(CWT_ISSUED_AT, Math.round(iss.getTime() / 1000));\n\n  if (monthsToExpire) {\n    let exp = new Date(iss);\n    exp.setMonth(exp.getMonth() + monthsToExpire);\n    cwt.set(CWT_EXPIRATION, Math.round(exp.getTime() / 1000));\n  }\n\n  if (issuer) {\n    cwt.set(CWT_ISSUER, issuer);\n  }\n\n  cwt.set(CWT_HCERT, new Map());\n  cwt.get(CWT_HCERT).set(CWT_HCERT_V1, payload);\n  return cwt;\n}\nexport async function parseCWT(cwt) {\n  if (cwt.get(CWT_HCERT)) return cwt.get(CWT_HCERT).get(CWT_HCERT_V1);else return JSON.parse(cwt.get(CWT_STRING_PAYLOAD));\n}\n\nfunction toBase64(bytes) {\n  return base64.fromByteArray(bytes);\n}\n\nfunction toBase64URL(bytes) {\n  return toBase64(bytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=+$/m, '');\n}\n\nfunction getCOSEHeaderParams(header) {\n  let headerObj; // Sometimes the header has to be decoded. \n\n  if (header instanceof Buffer || header instanceof Uint8Array) {\n    if (header.length == 0) {\n      return {};\n    }\n\n    headerObj = cbor.decode(header);\n  } // Sometimes the header is already decoded. \n\n\n  if (header instanceof Map) {\n    headerObj = header;\n  }\n\n  if (headerObj) {\n    let algorithm;\n    let kid;\n    if (headerObj.get(COSE_ALG_TAG)) algorithm = headerObj.get(COSE_ALG_TAG);\n    if (headerObj.get(COSE_KID_TAG)) kid = new Uint8Array(headerObj.get(COSE_KID_TAG));\n    return {\n      alg: algorithm,\n      kid: kid\n    };\n  }\n\n  return {};\n}\n\nasync function getIssuerKeyId(coseContent) {\n  let cborObj = cbor.decode(new Uint8Array(coseContent));\n\n  if (!cborObj) {\n    console.log(\"Not a readable COSE\");\n    return undefined;\n  }\n\n  let cborObjValue = cborObj.value;\n\n  if (!cborObjValue) {\n    if (Array.isArray(cborObj)) {\n      console.warn(\"COSE object with no Value field\", cborObj);\n      cborObjValue = cborObj;\n    } else {\n      console.log(\"COSE object with no Value field and no array\", cborObj);\n      return undefined;\n    }\n  }\n\n  let [protec, unprotec, payload, signature] = cborObjValue;\n  let cwtIssuer;\n\n  try {\n    let decodedPayload = cbor.decode(payload);\n\n    if (decodedPayload instanceof Map) {\n      cwtIssuer = decodedPayload.get(CWT_ISSUER);\n    }\n  } catch (err) {\n    console.log(payload, err);\n  }\n\n  let protectedData = getCOSEHeaderParams(protec);\n  let unProtectedData = getCOSEHeaderParams(unprotec);\n  return {\n    alg: protectedData.alg ? protectedData.alg : unProtectedData.alg,\n    kid: protectedData.kid ? protectedData.kid : unProtectedData.kid,\n    iss: cwtIssuer\n  };\n}\n\nexport async function verify(coseContent, addPublicKeyPem) {\n  let rawContents;\n  let plainObj;\n\n  try {\n    rawContents = await decodeCbor(coseContent);\n    let obj = await cbor.decodeFirst(coseContent);\n\n    if (obj.tag) {\n      obj = obj.value;\n    }\n\n    let [p, u, plaintext, signers] = obj;\n    plainObj = cbor.decode(plaintext);\n\n    if (!rawContents || !plaintext) {\n      return {\n        status: INVALID_SIGNING_FORMAT,\n        raw: rawContents\n      };\n    }\n  } catch (err) {\n    console.log(err);\n    return {\n      status: INVALID_SIGNING_FORMAT,\n      raw: rawContents\n    };\n  }\n\n  const keyID = await getIssuerKeyId(coseContent);\n  if (!keyID || !keyID.kid) return {\n    status: KID_NOT_INCLUDED,\n    contents: plainObj,\n    raw: rawContents\n  }; // Tries B64URL First\n\n  let issuer = await resolveKey(toBase64(keyID.kid)); // if not then use the key passed on the parameter. \n\n  if (!issuer && addPublicKeyPem) {\n    issuer = {\n      didDocument: addPublicKeyPem,\n      status: \"current\"\n    };\n  }\n\n  if (!issuer) {\n    return {\n      status: ISSUER_NOT_TRUSTED,\n      contents: plainObj,\n      raw: rawContents\n    };\n  }\n\n  let jwk = getJWTFromPEM(issuer.didDocument);\n\n  switch (issuer.status) {\n    case \"revoked\":\n      return {\n        status: REVOKED_KEYS,\n        contents: plainObj,\n        issuer: issuer,\n        raw: rawContents\n      };\n\n    case \"terminated\":\n      return {\n        status: TERMINATED_KEYS,\n        contents: plainObj,\n        issuer: issuer,\n        raw: rawContents\n      };\n\n    case \"expired\":\n      return {\n        status: EXPIRED_KEYS,\n        contents: plainObj,\n        issuer: issuer,\n        raw: rawContents\n      };\n  }\n\n  try {\n    jwk.kid = toBase64(keyID.kid);\n    const verified = await cose.verify(coseContent, {\n      'jwk': jwk\n    });\n    return {\n      status: VERIFIED,\n      contents: cbor.decode(verified),\n      issuer: issuer,\n      raw: rawContents\n    };\n  } catch (err) {\n    return {\n      status: INVALID_SIGNATURE,\n      contents: plainObj,\n      issuer: issuer,\n      raw: rawContents\n    };\n  }\n}\n\nfunction removePrefix(uri) {\n  let data = uri; // Backwards compatibility.\n\n  if (data.startsWith(URI_SCHEMA)) {\n    data = data.substring(3);\n\n    if (data.startsWith(':')) {\n      data = data.substring(1);\n    } else {\n      console.warn(\"Warning: unsafe HC1: header from older versions\");\n    }\n\n    ;\n  } else {\n    console.warn(\"Warning: no HC1: header from older versions\");\n  }\n\n  ;\n  return data;\n}\n\nexport async function unpack(uri) {\n  const data = removePrefix(uri);\n\n  try {\n    let unencodedData = base45.decode(data); // Check if it was zipped (Backwards compatibility.)\n\n    if (unencodedData[0] == 0x78) {\n      unencodedData = zlib.inflate(unencodedData);\n    }\n\n    return unencodedData;\n  } catch (err) {\n    console.log(err);\n    return;\n  }\n}\n\nasync function decodeCbor(cborObj) {\n  if (cborObj instanceof Buffer || cborObj instanceof Uint8Array) {\n    try {\n      cborObj = cbor.decode(cborObj);\n\n      for (var key in cborObj) {\n        cborObj[key] = await decodeCbor(cborObj[key]);\n      }\n    } catch {\n      cborObj = cborObj.toString('base64');\n    }\n  }\n\n  if (Array.isArray(cborObj)) {\n    for (let i = 0; i < cborObj.length; i++) {\n      cborObj[i] = await decodeCbor(cborObj[i]);\n    }\n  }\n\n  if (cborObj instanceof Map) {\n    for (const [key, value] of cborObj.entries()) {\n      cborObj.set(key, await decodeCbor(cborObj.get(key)));\n    }\n  }\n\n  return cborObj;\n}\n\nexport async function debug(uri) {\n  return await decodeCbor(await unpack(uri));\n}\nexport async function unpackAndVerify(uri, publicKeyPem) {\n  const data = removePrefix(uri);\n\n  try {\n    // Checks if the data is Base45\n    base45.decode(data);\n  } catch (err) {\n    console.log(err);\n    return {\n      status: INVALID_ENCODING,\n      qr: uri\n    };\n  }\n\n  const cbor = await unpack(uri);\n\n  if (!cbor) {\n    return {\n      status: INVALID_COMPRESSION,\n      qr: uri\n    };\n  }\n\n  const verified = await verify(cbor, publicKeyPem);\n  return { ...verified,\n    qr: uri\n  };\n}\nexport async function pack(payload) {\n  const zipped = zlib.deflate(payload);\n  return URI_SCHEMA + ':' + base45.encode(zipped);\n}\nexport async function signAndPack(payload, publicKeyPem, privateKeyP8) {\n  return await pack(await sign(payload, publicKeyPem, privateKeyP8));\n}\nexport { addCachedCerts, addCachedKeys };","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/@pathcheck/dcc-sdk/lib/dcc.js"],"names":["cose","createHash","rawHash","zlib","cbor","base64","base45","resolveKey","addCachedCerts","addCachedKeys","getJWTFromPEM","getDERFromPEM","URI_SCHEMA","CWT_ISSUER","CWT_SUBJECT","CWT_AUDIENCE","CWT_EXPIRATION","CWT_NOT_BEFORE","CWT_ISSUED_AT","CWT_ID","CWT_HCERT","CWT_HCERT_V1","CWT_STRING_PAYLOAD","COSE_ALG_TAG","COSE_KID_TAG","NOT_SUPPORTED","INVALID_ENCODING","INVALID_COMPRESSION","INVALID_SIGNING_FORMAT","KID_NOT_INCLUDED","ISSUER_NOT_TRUSTED","TERMINATED_KEYS","EXPIRED_KEYS","REVOKED_KEYS","INVALID_SIGNATURE","VERIFIED","getKeyIDFromPEM","pem","update","digest","slice","sign","payload","publicKeyPem","privateKeyP8","jwt","keyId","headers","alg","signer","cborPayload","encode","create","makeCWT","monthsToExpire","issuer","cwt","Map","iss","Date","set","Math","round","getTime","exp","setMonth","getMonth","get","parseCWT","JSON","parse","toBase64","bytes","fromByteArray","toBase64URL","replace","getCOSEHeaderParams","header","headerObj","Buffer","Uint8Array","length","decode","algorithm","kid","getIssuerKeyId","coseContent","cborObj","console","log","undefined","cborObjValue","value","Array","isArray","warn","protec","unprotec","signature","cwtIssuer","decodedPayload","err","protectedData","unProtectedData","verify","addPublicKeyPem","rawContents","plainObj","decodeCbor","obj","decodeFirst","tag","p","u","plaintext","signers","status","raw","keyID","contents","didDocument","jwk","verified","removePrefix","uri","data","startsWith","substring","unpack","unencodedData","inflate","key","toString","i","entries","debug","unpackAndVerify","qr","pack","zipped","deflate","signAndPack"],"mappings":"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","sourcesContent":["// Needs to import only the sign and verify functions, not the encrypt and decrypt due to additional dependencies. \nimport * as cose from './cose-js/sign.js'\nimport {createHash as rawHash} from \"sha256-uint8array\";\n\nimport zlib from 'pako';\nimport * as cbor from 'cbor';\n\nimport * as base64 from 'base64-js';\n\nimport base45 from 'base45';\n\nimport { resolveKey, addCachedCerts, addCachedKeys } from './resolver'; \nimport { getJWTFromPEM, getDERFromPEM } from './key-parser';\n\nconst URI_SCHEMA = 'HC1';\n\nconst CWT_ISSUER = 1;\nconst CWT_SUBJECT = 2;\nconst CWT_AUDIENCE = 3;\nconst CWT_EXPIRATION = 4;\nconst CWT_NOT_BEFORE = 5;\nconst CWT_ISSUED_AT = 6;\nconst CWT_ID = 7;\nconst CWT_HCERT = -260;\nconst CWT_HCERT_V1 = 1;\n\nconst CWT_STRING_PAYLOAD = 99;\n\nconst COSE_ALG_TAG = 1;\nconst COSE_KID_TAG = 4;\n\nconst NOT_SUPPORTED = \"not_supported\";                  // QR Standard not supported by this algorithm\nconst INVALID_ENCODING = \"invalid_encoding\";            // could not decode Base45 for DCC, Base10 for SHC\nconst INVALID_COMPRESSION = \"invalid_compression\";      // could not decompress the byte array\nconst INVALID_SIGNING_FORMAT = \"invalid_signing_format\";// invalid COSE, JOSE, W3C VC Payload\nconst KID_NOT_INCLUDED = \"kid_not_included\";            // unable to resolve the issuer ID\nconst ISSUER_NOT_TRUSTED = \"issuer_not_trusted\";        // issuer is not found in the registry\nconst TERMINATED_KEYS = \"terminated_keys\";              // issuer was terminated by the registry\nconst EXPIRED_KEYS = \"expired_keys\";                    // keys expired\nconst REVOKED_KEYS = \"revoked_keys\";                    // keys were revoked by the issuer\nconst INVALID_SIGNATURE = \"invalid_signature\";          // signature doesn't match\nconst VERIFIED = \"verified\";                            // Verified content.\n\nfunction getKeyIDFromPEM(pem) {\n  return rawHash().update(getDERFromPEM(pem)).digest().slice(0,8);\n}\n\nexport async function sign(payload, publicKeyPem, privateKeyP8) {\n  const jwt = getJWTFromPEM(publicKeyPem);\n  const keyId = getKeyIDFromPEM(publicKeyPem);\n\n  const headers = {\n    'p': { \n      'alg': jwt.alg, \n      'kid': keyId \n    }, \n    'u': {}\n  };\n\n  const signer = {\n    'key': {\n      'pkcs8': getDERFromPEM(privateKeyP8) \n    }\n  };\n\n  const cborPayload = cbor.encode(payload);\n  return cose.create(headers, cborPayload, signer);\n}\n\n/*\n * I am not sure if I should build this by hand. \n */\nexport async function makeCWT(payload, monthsToExpire, issuer) {\n  let cwt = new Map();\n\n  let iss = new Date();\n  cwt.set(CWT_ISSUED_AT, Math.round(iss.getTime()/1000));\n\n  if (monthsToExpire) {\n    let exp = new Date(iss);\n    exp.setMonth(exp.getMonth()+monthsToExpire);\n    cwt.set(CWT_EXPIRATION, Math.round(exp.getTime()/1000));\n  }\n  \n  if (issuer) {\n    cwt.set(CWT_ISSUER, issuer);\n  }\n\n  cwt.set(CWT_HCERT, new Map()); \n  cwt.get(CWT_HCERT).set(CWT_HCERT_V1, payload);  \n  return cwt;\n}\n\nexport async function parseCWT(cwt) {\n  if (cwt.get(CWT_HCERT))\n    return cwt.get(CWT_HCERT).get(CWT_HCERT_V1);\n  else \n    return JSON.parse(cwt.get(CWT_STRING_PAYLOAD))\n}\n\nfunction toBase64(bytes) {\n  return base64.fromByteArray(bytes);\n}\n\nfunction toBase64URL(bytes) {\n  return toBase64(bytes).replace(/\\+/g,'-').replace(/\\//g,'_').replace(/\\=+$/m,'');\n}\n\nfunction getCOSEHeaderParams(header) {\n  let headerObj;\n  // Sometimes the header has to be decoded. \n  if (header instanceof Buffer || header  instanceof Uint8Array) {\n    if (header.length == 0) {\n      return {};\n    }\n    headerObj = cbor.decode(header);\n  } \n\n  // Sometimes the header is already decoded. \n  if (header instanceof Map) {\n    headerObj = header;\n  }\n\n  if (headerObj) {\n    let algorithm;\n    let kid; \n\n    if (headerObj.get(COSE_ALG_TAG))\n      algorithm = headerObj.get(COSE_ALG_TAG);\n    if (headerObj.get(COSE_KID_TAG))\n      kid = new Uint8Array(headerObj.get(COSE_KID_TAG));\n\n    return {alg: algorithm, kid: kid};\n  }\n  return {};\n} \n\nasync function getIssuerKeyId(coseContent) {\n  let cborObj = cbor.decode(new Uint8Array(coseContent));\n\n  if (!cborObj) { \n    console.log(\"Not a readable COSE\");\n    return undefined;\n  }\n\n  let cborObjValue = cborObj.value;\n\n  if (!cborObjValue) { \n    if (Array.isArray(cborObj)) {\n      console.warn(\"COSE object with no Value field\", cborObj);\n      cborObjValue = cborObj;\n    } else { \n      console.log(\"COSE object with no Value field and no array\", cborObj);\n      return undefined;\n    }\n  }  \n\n  let [protec, unprotec, payload, signature] = cborObjValue;\n\n  let cwtIssuer;\n\n  try {\n    let decodedPayload = cbor.decode(payload); \n    if (decodedPayload instanceof Map) {\n      cwtIssuer = decodedPayload.get(CWT_ISSUER);\n    }\n  } catch (err) {\n    console.log(payload, err);\n  }\n\n  let protectedData = getCOSEHeaderParams(protec);\n  let unProtectedData = getCOSEHeaderParams(unprotec);\n\n  return {\n    alg: protectedData.alg ? protectedData.alg : unProtectedData.alg, \n    kid: protectedData.kid ? protectedData.kid : unProtectedData.kid, \n    iss: cwtIssuer\n  };\n}\n\nexport async function verify(coseContent, addPublicKeyPem) {\n  let rawContents\n  let plainObj\n  try {\n    rawContents = await decodeCbor(coseContent);\n    let obj = await cbor.decodeFirst(coseContent)\n    if (obj.tag) { obj = obj.value; }\n    let [p, u, plaintext, signers] = obj;\n    plainObj = cbor.decode(plaintext)\n    \n    if (!rawContents || !plaintext) {\n      return { status: INVALID_SIGNING_FORMAT, raw: rawContents }\n    }\n  } catch (err) {\n    console.log(err)\n    return { status: INVALID_SIGNING_FORMAT, raw: rawContents }\n  }\n\n  const keyID = await getIssuerKeyId(coseContent);\n\n  if (!keyID || !keyID.kid) return { status: KID_NOT_INCLUDED, contents: plainObj, raw: rawContents }\n\n  // Tries B64URL First\n  let issuer = await resolveKey(toBase64(keyID.kid));\n  \n  // if not then use the key passed on the parameter. \n  if (!issuer && addPublicKeyPem) {\n    issuer = { didDocument: addPublicKeyPem, status: \"current\" }\n  }\n\n  if (!issuer) {\n    return { status: ISSUER_NOT_TRUSTED, contents: plainObj, raw: rawContents };\n  }\n\n  let jwk = getJWTFromPEM(issuer.didDocument);\n\n  switch (issuer.status) {\n    case \"revoked\": return    { status: REVOKED_KEYS, contents: plainObj, issuer: issuer, raw: rawContents }\n    case \"terminated\": return { status: TERMINATED_KEYS, contents: plainObj, issuer: issuer, raw: rawContents }\n    case \"expired\": return    { status: EXPIRED_KEYS, contents: plainObj, issuer: issuer, raw: rawContents }\n  }\n\n  try {\n    jwk.kid = toBase64(keyID.kid);\n\n    const verified = await cose.verify(coseContent, { 'jwk': jwk });\n    return { status: VERIFIED, contents: cbor.decode(verified), issuer: issuer, raw: rawContents }\n  } catch (err) {\n     return { status: INVALID_SIGNATURE, contents: plainObj, issuer: issuer, raw: rawContents }\n  }\n}\n\nfunction removePrefix(uri) {\n  let data = uri;\n\n  // Backwards compatibility.\n  if (data.startsWith(URI_SCHEMA)) {\n    data = data.substring(3)\n    if (data.startsWith(':')) {\n      data = data.substring(1)\n    } else {\n      console.warn(\"Warning: unsafe HC1: header from older versions\");\n    };\n  } else {\n      console.warn(\"Warning: no HC1: header from older versions\");\n  };\n  return data;\n}\n\nexport async function unpack(uri) {\n  const data = removePrefix(uri);\n\n  try {\n    let unencodedData = base45.decode(data);\n\n    // Check if it was zipped (Backwards compatibility.)\n    if (unencodedData[0] == 0x78) {\n      unencodedData = zlib.inflate(unencodedData);\n    }\n\n    return unencodedData;\n  } catch (err) {\n    console.log(err)\n    return\n  }\n}\n\nasync function decodeCbor(cborObj) {\n  if (cborObj instanceof Buffer || cborObj instanceof Uint8Array) {\n    try {  \n      cborObj = cbor.decode(cborObj);\n      for (var key in cborObj) {\n        cborObj[key] = await decodeCbor(cborObj[key]);\n      }\n    } catch {\n      cborObj = cborObj.toString('base64');\n    }\n  } \n\n  if (Array.isArray(cborObj)) {\n    for (let i=0; i<cborObj.length; i++) {\n      cborObj[i] = await decodeCbor(cborObj[i])\n    }\n  }\n\n  if (cborObj instanceof Map) {\n    for (const [key, value] of cborObj.entries()) {\n      cborObj.set(key, await decodeCbor(cborObj.get(key)));\n    }\n  }\n\n  return cborObj;\n}\n\nexport async function debug(uri) {\n  return await decodeCbor(await unpack(uri));\n}\n\nexport async function unpackAndVerify(uri, publicKeyPem) {\n  const data = removePrefix(uri);\n\n  try { // Checks if the data is Base45\n    base45.decode(data);\n  } catch (err) {\n    console.log(err)\n    return { status: INVALID_ENCODING, qr: uri };\n  }\n\n  const cbor = await unpack(uri);\n\n  if (!cbor) { \n    return { status: INVALID_COMPRESSION, qr: uri };\n  }\n\n  const verified = await verify(cbor, publicKeyPem);\n  return {...verified, qr: uri} ;\n}\n\nexport async function pack(payload) {\n  const zipped = zlib.deflate(payload);\n  return URI_SCHEMA + ':' + base45.encode(zipped);\n}\n\nexport async function signAndPack(payload, publicKeyPem, privateKeyP8) {\n  return await pack(await sign(payload, publicKeyPem, privateKeyP8));\n}\n\nexport {addCachedCerts, addCachedKeys};\n\n"]},"metadata":{},"sourceType":"module"}
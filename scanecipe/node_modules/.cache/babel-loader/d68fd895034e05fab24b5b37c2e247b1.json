{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst Decoder = require('./decoder');\n\nconst utils = require('./utils');\n\nconst NoFilter = require('nofilter');\n\nconst {\n  MT,\n  SYMS\n} = require('./constants');\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\n\n\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb:\n        /** @type {diagnoseCallback} */\n        opts\n      };\n\n    case 'string':\n      return {\n        options: {\n          encoding:\n          /** @type {BufferEncoding} */\n          opts\n        },\n        cb\n      };\n\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\n\n\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n    super({ ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding\n    });\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n\n        return cb();\n      }\n\n      return cb(er);\n    });\n  }\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @throws {TypeError} Input not provided.\n   * @returns {Promise} If callback not specified.\n   */\n\n\n  static diagnose(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    ({\n      options,\n      cb\n    } = normalizeOptions(options, cb));\n    const {\n      encoding = 'hex',\n      ...opts\n    } = options;\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n  /**\n   * @ignore\n   */\n\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString());\n    } else {\n      this.emit('error', er);\n    }\n  }\n  /** @private */\n\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n  /** @private */\n\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ');\n        }\n\n        break;\n\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ');\n          } else {\n            this.push(', ');\n          }\n        }\n\n    }\n  }\n  /** @private */\n\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n\n    this._fore(parent_mt, pos);\n\n    const fb = this.float_bytes;\n    this.float_bytes = -1;\n    this.push(utils.cborValueToString(val, fb));\n  }\n  /** @private */\n\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n\n      case MT.ARRAY:\n        this.push('[');\n        break;\n\n      case MT.MAP:\n        this.push('{');\n        break;\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n\n    if (tag === SYMS.STREAM) {\n      this.push('_ ');\n    }\n  }\n  /** @private */\n\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')');\n        break;\n\n      case MT.ARRAY:\n        this.push(']');\n        break;\n\n      case MT.MAP:\n        this.push('}');\n        break;\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')');\n        break;\n    }\n  }\n  /** @private */\n\n\n  _on_data() {\n    this.push(this.separator);\n  }\n\n}\n\nmodule.exports = Diagnose;","map":{"version":3,"sources":["C:/Users/ethan/Documents/stormhacks-2024/scanecipe/node_modules/cbor/lib/diagnose.js"],"names":["stream","require","Decoder","utils","NoFilter","MT","SYMS","normalizeOptions","opts","cb","options","encoding","TypeError","Diagnose","Transform","constructor","separator","stream_errors","tags","max_depth","preferWeb","superOpts","readableObjectMode","writableObjectMode","float_bytes","parser","on","_on_more","bind","_on_value","_on_start","_on_stop","_on_data","_on_error","_transform","fresh","write","_flush","er","diagnose","input","bs","d","p","toString","Promise","resolve","reject","pipe","guessEncoding","push","emit","mt","len","parent_mt","pos","SIMPLE_FLOAT","_fore","BYTE_STRING","UTF8_STRING","ARRAY","MAP","val","BREAK","fb","cborValueToString","tag","TAG","STREAM","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst Decoder = require('./decoder')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst {MT, SYMS} = require('./constants')\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      }\n      return cb(er)\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @throws {TypeError} Input not provided.\n   * @returns {Promise} If callback not specified.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString())\n    } else {\n      this.emit('error', er)\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len]\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ')\n          } else {\n            this.push(', ')\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    const fb = this.float_bytes\n    this.float_bytes = -1\n    this.push(utils.cborValueToString(val, fb))\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ')\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')')\n        break\n      case MT.ARRAY:\n        this.push(']')\n        break\n      case MT.MAP:\n        this.push('}')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')')\n        break\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/**\n * Modified version of @cose-js with added support for RSASSA-PSS\n */\nimport * as cbor from 'cbor';\nimport webcrypto from 'isomorphic-webcrypto';\nimport * as common from './common';\nconst EMPTY_BUFFER = common.EMPTY_BUFFER;\nconst Tagged = cbor.Tagged;\nconst SignTag = 98;\nconst Sign1Tag = 18;\n\nfunction subtle() {\n  return webcrypto.subtle ? webcrypto.subtle : window.crypto.subtle;\n}\n\nconst AlgFromTags = {};\nAlgFromTags[-7] = {\n  'sign': 'ES256',\n  'digest': 'SHA-256'\n};\nAlgFromTags[-35] = {\n  'sign': 'ES384',\n  'digest': 'SHA-384'\n};\nAlgFromTags[-36] = {\n  'sign': 'ES512',\n  'digest': 'SHA-512'\n};\nAlgFromTags[-37] = {\n  'sign': 'PS256',\n  'digest': 'SHA-256'\n};\nAlgFromTags[-38] = {\n  'sign': 'PS384',\n  'digest': 'SHA-384'\n};\nAlgFromTags[-39] = {\n  'sign': 'PS512',\n  'digest': 'SHA-512'\n};\nconst COSEAlgToNodeAlg = {\n  'ES256': {\n    'sign': 'ECDSA',\n    kty: 'EC',\n    'curve': 'P-256',\n    'digest': 'SHA-256'\n  },\n  'ES384': {\n    'sign': 'ECDSA',\n    kty: 'EC',\n    'curve': 'P-384',\n    'digest': 'SHA-384'\n  },\n  'ES512': {\n    'sign': 'ECDSA',\n    kty: 'EC',\n    'curve': 'P-521',\n    'digest': 'SHA-512'\n  },\n  'PS256': {\n    'sign': 'RSA-PSS',\n    kty: 'RSA',\n    'digest': 'SHA-256',\n    saltLength: 32\n  },\n  'PS384': {\n    'sign': 'RSA-PSS',\n    kty: 'RSA',\n    'digest': 'SHA-384',\n    saltLength: 48\n  },\n  'PS512': {\n    'sign': 'RSA-PSS',\n    kty: 'RSA',\n    'digest': 'SHA-512',\n    saltLength: 64\n  }\n};\n\nasync function doSign(SigStructure, signer, alg) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n\n  let toBeSigned = cbor.encode(SigStructure);\n  let algo = {\n    name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n    namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest,\n    saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n  const importedKey = await subtle().importKey('pkcs8', signer.key.pkcs8, algo, false, ['sign']);\n  return await subtle().sign(algo, importedKey, toBeSigned);\n}\n\nexport function create(headers, payload, signers, options) {\n  options = options || {};\n  let u = headers.u || {};\n  let p = headers.p || {};\n  p = common.TranslateHeaders(p);\n  u = common.TranslateHeaders(u);\n  let bodyP = p || {};\n  bodyP = bodyP.size === 0 ? EMPTY_BUFFER : cbor.encode(bodyP);\n\n  if (Array.isArray(signers)) {\n    if (signers.length === 0) {\n      throw new Error('There has to be at least one signer');\n    }\n\n    if (signers.length > 1) {\n      throw new Error('Only one signer is supported');\n    } // TODO handle multiple signers\n\n\n    const signer = signers[0];\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    let signerP = signer.p || {};\n    let signerU = signer.u || {};\n    signerP = common.TranslateHeaders(signerP);\n    signerU = common.TranslateHeaders(signerU);\n    const alg = signerP.get(common.HeaderParameters.alg);\n    signerP = signerP.size === 0 ? EMPTY_BUFFER : cbor.encode(signerP);\n    const SigStructure = ['Signature', bodyP, signerP, externalAAD, payload];\n    return doSign(SigStructure, signer, alg).then(sig => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n\n      const signed = [p, u, payload, [[signerP, signerU, sig]]];\n      return cbor.encode(options.excludetag ? signed : new Tagged(SignTag, signed));\n    });\n  } else {\n    const signer = signers;\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    const alg = p.get(common.HeaderParameters.alg) || u.get(common.HeaderParameters.alg);\n    const SigStructure = ['Signature1', bodyP, externalAAD, payload];\n    return doSign(SigStructure, signer, alg).then(sig => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n\n      const signed = [p, u, payload, sig];\n      return cbor.encodeCanonical(options.excludetag ? signed : new Tagged(Sign1Tag, signed));\n    });\n  }\n}\n;\n\nasync function doVerify(SigStructure, verifier, alg, sig) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n\n  const ToBeSigned = cbor.encode(SigStructure);\n  let algo = {\n    name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n    namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest,\n    saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n  let jwkData = {\n    kty: COSEAlgToNodeAlg[AlgFromTags[alg].sign].kty,\n    crv: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    e: verifier.jwk.e,\n    n: verifier.jwk.n,\n    x: verifier.jwk.x,\n    y: verifier.jwk.y\n  };\n  const importedKey = await subtle().importKey('jwk', jwkData, algo, false, ['verify']);\n  return await subtle().verify(algo, importedKey, sig, ToBeSigned);\n}\n\nfunction getSigner(signers, verifier) {\n  for (let i = 0; i < signers.length; i++) {\n    const kid = signers[i][1].get(common.HeaderParameters.kid); // TODO create constant for header locations\n\n    if (kid.equals(Buffer.from(verifier.jwk.kid, 'utf8'))) {\n      return signers[i];\n    }\n  }\n}\n\nfunction getCommonParameter(first, second, parameter) {\n  let result;\n\n  if (first.get) {\n    result = first.get(parameter);\n  }\n\n  if (!result && second.get) {\n    result = second.get(parameter);\n  }\n\n  return result;\n}\n\nexport function verify(payload, verifier, publicKeyPem, options) {\n  options = options || {};\n  return cbor.decodeFirst(payload).then(obj => {\n    let type = options.defaultType ? options.defaultType : SignTag;\n\n    if (obj instanceof Tagged) {\n      if (obj.tag !== SignTag && obj.tag !== Sign1Tag) {\n        throw new Error('Unexpected cbor tag, \\'' + obj.tag + '\\'');\n      }\n\n      type = obj.tag;\n      obj = obj.value;\n    }\n\n    if (!Array.isArray(obj)) {\n      throw new Error('Expecting Array');\n    }\n\n    if (obj.length !== 4) {\n      throw new Error('Expecting Array of lenght 4');\n    }\n\n    let [p, u, plaintext, signers] = obj;\n\n    if (type === SignTag && !Array.isArray(signers)) {\n      throw new Error('Expecting signature Array');\n    }\n\n    p = !p.length ? EMPTY_BUFFER : cbor.decodeFirstSync(p);\n    u = !u.size ? EMPTY_BUFFER : u;\n    let signer = type === SignTag ? getSigner(signers, verifier) : signers;\n\n    if (!signer) {\n      throw new Error('Failed to find signer with kid' + verifier.key.kid);\n    }\n\n    if (type === SignTag) {\n      const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n      let [signerP,, sig] = signer;\n      signerP = !signerP.length ? EMPTY_BUFFER : signerP;\n      p = !p.size ? EMPTY_BUFFER : cbor.encode(p);\n      const signerPMap = cbor.decode(signerP);\n      const alg = signerPMap.get(common.HeaderParameters.alg);\n      const SigStructure = ['Signature', p, signerP, externalAAD, plaintext];\n      return doVerify(SigStructure, verifier, alg, sig).then(() => {\n        return plaintext;\n      });\n    } else {\n      const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n      const alg = getCommonParameter(p, u, common.HeaderParameters.alg);\n      p = !p.size ? EMPTY_BUFFER : cbor.encode(p);\n      const SigStructure = ['Signature1', p, externalAAD, plaintext];\n      return doVerify(SigStructure, verifier, alg, signer, publicKeyPem).then(verified => {\n        if (verified) return plaintext;else return undefined;\n      });\n    }\n  });\n}\n;","map":{"version":3,"sources":["/Users/jakechoi/Documents/StormhacksFall2024/stormhacks-2024/scanecipe/node_modules/@pathcheck/dcc-sdk/lib/cose-js/sign.js"],"names":["cbor","webcrypto","common","EMPTY_BUFFER","Tagged","SignTag","Sign1Tag","subtle","window","crypto","AlgFromTags","COSEAlgToNodeAlg","kty","saltLength","doSign","SigStructure","signer","alg","Error","sign","toBeSigned","encode","algo","name","namedCurve","curve","hash","digest","importedKey","importKey","key","pkcs8","create","headers","payload","signers","options","u","p","TranslateHeaders","bodyP","size","Array","isArray","length","externalAAD","signerP","signerU","get","HeaderParameters","then","sig","encodep","signed","excludetag","encodeCanonical","doVerify","verifier","ToBeSigned","jwkData","crv","e","jwk","n","x","y","verify","getSigner","i","kid","equals","Buffer","from","getCommonParameter","first","second","parameter","result","publicKeyPem","decodeFirst","obj","type","defaultType","tag","value","plaintext","decodeFirstSync","signerPMap","decode","verified","undefined"],"mappings":"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","sourcesContent":["/**\n * Modified version of @cose-js with added support for RSASSA-PSS\n */\n\nimport * as cbor from 'cbor';\nimport webcrypto from 'isomorphic-webcrypto';\nimport * as common from './common';\n\nconst EMPTY_BUFFER = common.EMPTY_BUFFER;\nconst Tagged = cbor.Tagged;\n\nconst SignTag = 98;\nconst Sign1Tag = 18;\n\nfunction subtle() {\n  return webcrypto.subtle ? webcrypto.subtle : window.crypto.subtle;\n}\n\nconst AlgFromTags = {};\nAlgFromTags[-7] = { 'sign': 'ES256', 'digest': 'SHA-256' };  \nAlgFromTags[-35] = { 'sign': 'ES384', 'digest': 'SHA-384' };\nAlgFromTags[-36] = { 'sign': 'ES512', 'digest': 'SHA-512' };\nAlgFromTags[-37] = { 'sign': 'PS256', 'digest': 'SHA-256' };\nAlgFromTags[-38] = { 'sign': 'PS384', 'digest': 'SHA-384' };\nAlgFromTags[-39] = { 'sign': 'PS512', 'digest': 'SHA-512' };\n\nconst COSEAlgToNodeAlg = {\n  'ES256': { 'sign': 'ECDSA', kty: 'EC', 'curve': 'P-256', 'digest': 'SHA-256' },\n  'ES384': { 'sign': 'ECDSA', kty: 'EC', 'curve': 'P-384', 'digest': 'SHA-384' },\n  'ES512': { 'sign': 'ECDSA', kty: 'EC', 'curve': 'P-521', 'digest': 'SHA-512' },\n  'PS256': { 'sign': 'RSA-PSS', kty: 'RSA', 'digest': 'SHA-256', saltLength: 32  },\n  'PS384': { 'sign': 'RSA-PSS', kty: 'RSA', 'digest': 'SHA-384', saltLength: 48  },\n  'PS512': { 'sign': 'RSA-PSS', kty: 'RSA', 'digest': 'SHA-512', saltLength: 64  }\n};\n\nasync function doSign (SigStructure, signer, alg) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n\n  let toBeSigned = cbor.encode(SigStructure);\n  let algo = {\n      name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n      namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n      hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest, \n      saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n\n  const importedKey = await subtle().importKey('pkcs8', signer.key.pkcs8, algo, false, ['sign']); \n  return await subtle().sign(algo, importedKey, toBeSigned);\n}\n\nexport function create(headers, payload, signers, options) {\n  options = options || {};\n  let u = headers.u || {};\n  let p = headers.p || {};\n\n  p = common.TranslateHeaders(p);\n  u = common.TranslateHeaders(u);\n  let bodyP = p || {};\n  bodyP = (bodyP.size === 0) ? EMPTY_BUFFER : cbor.encode(bodyP);\n  if (Array.isArray(signers)) {\n    if (signers.length === 0) {\n      throw new Error('There has to be at least one signer');\n    }\n    if (signers.length > 1) {\n      throw new Error('Only one signer is supported');\n    }\n    // TODO handle multiple signers\n    const signer = signers[0];\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    let signerP = signer.p || {};\n    let signerU = signer.u || {};\n\n    signerP = common.TranslateHeaders(signerP);\n    signerU = common.TranslateHeaders(signerU);\n    const alg = signerP.get(common.HeaderParameters.alg);\n    signerP = (signerP.size === 0) ? EMPTY_BUFFER : cbor.encode(signerP);\n\n    const SigStructure = [\n      'Signature',\n      bodyP,\n      signerP,\n      externalAAD,\n      payload\n    ];\n    return doSign(SigStructure, signer, alg).then((sig) => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n      const signed = [p, u, payload, [[signerP, signerU, sig]]];\n      return cbor.encode(options.excludetag ? signed : new Tagged(SignTag, signed));\n    });\n  } else {\n    const signer = signers;\n    const externalAAD = signer.externalAAD || EMPTY_BUFFER;\n    const alg = p.get(common.HeaderParameters.alg) || u.get(common.HeaderParameters.alg);\n    const SigStructure = [\n      'Signature1',\n      bodyP,\n      externalAAD,\n      payload\n    ];\n    return doSign(SigStructure, signer, alg).then((sig) => {\n      if (p.size === 0 && options.encodep === 'empty') {\n        p = EMPTY_BUFFER;\n      } else {\n        p = cbor.encode(p);\n      }\n      const signed = [p, u, payload, sig];\n      return cbor.encodeCanonical(options.excludetag ? signed : new Tagged(Sign1Tag, signed));\n    });\n  }\n};\n\nasync function doVerify (SigStructure, verifier, alg, sig) {\n  if (!AlgFromTags[alg]) {\n    throw new Error('Unknown algorithm, ' + alg);\n  }\n  if (!COSEAlgToNodeAlg[AlgFromTags[alg].sign]) {\n    throw new Error('Unsupported algorithm, ' + AlgFromTags[alg].sign);\n  }\n  const ToBeSigned = cbor.encode(SigStructure);\n\n  let algo = {\n      name: COSEAlgToNodeAlg[AlgFromTags[alg].sign].sign,\n      namedCurve: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n      hash: COSEAlgToNodeAlg[AlgFromTags[alg].sign].digest, \n      saltLength: COSEAlgToNodeAlg[AlgFromTags[alg].sign].saltLength\n  };\n\n  let jwkData = {\n    kty: COSEAlgToNodeAlg[AlgFromTags[alg].sign].kty,\n    crv: COSEAlgToNodeAlg[AlgFromTags[alg].sign].curve,\n    e: verifier.jwk.e,\n    n: verifier.jwk.n,\n    x: verifier.jwk.x,\n    y: verifier.jwk.y\n  };\n\n  const importedKey = await subtle().importKey('jwk', jwkData, algo, false, ['verify']);\n  return await subtle().verify(algo, importedKey, sig, ToBeSigned); \n}\n\nfunction getSigner (signers, verifier) {\n  for (let i = 0; i < signers.length; i++) {\n    const kid = signers[i][1].get(common.HeaderParameters.kid); // TODO create constant for header locations\n    if (kid.equals(Buffer.from(verifier.jwk.kid, 'utf8'))) {\n      return signers[i];\n    }\n  }\n}\n\nfunction getCommonParameter (first, second, parameter) {\n  let result;\n  if (first.get) {\n    result = first.get(parameter);\n  }\n  if (!result && second.get) {\n    result = second.get(parameter);\n  }\n  return result;\n}\n\nexport function verify(payload, verifier, publicKeyPem, options) {\n  options = options || {};\n  return cbor.decodeFirst(payload)\n    .then((obj) => {\n      let type = options.defaultType ? options.defaultType : SignTag;\n      if (obj instanceof Tagged) {\n        if (obj.tag !== SignTag && obj.tag !== Sign1Tag) {\n          throw new Error('Unexpected cbor tag, \\'' + obj.tag + '\\'');\n        }\n        type = obj.tag;\n        obj = obj.value;\n      }\n\n      if (!Array.isArray(obj)) {\n        throw new Error('Expecting Array');\n      }\n\n      if (obj.length !== 4) {\n        throw new Error('Expecting Array of lenght 4');\n      }\n\n      let [p, u, plaintext, signers] = obj;\n\n      if (type === SignTag && !Array.isArray(signers)) {\n        throw new Error('Expecting signature Array');\n      }\n\n      p = (!p.length) ? EMPTY_BUFFER : cbor.decodeFirstSync(p);\n      u = (!u.size) ? EMPTY_BUFFER : u;\n\n      let signer = (type === SignTag ? getSigner(signers, verifier) : signers);\n\n      if (!signer) {\n        throw new Error('Failed to find signer with kid' + verifier.key.kid);\n      }\n\n      if (type === SignTag) {\n        const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n        let [signerP, , sig] = signer;\n        signerP = (!signerP.length) ? EMPTY_BUFFER : signerP;\n        p = (!p.size) ? EMPTY_BUFFER : cbor.encode(p);\n        const signerPMap = cbor.decode(signerP);\n        const alg = signerPMap.get(common.HeaderParameters.alg);\n        const SigStructure = [\n          'Signature',\n          p,\n          signerP,\n          externalAAD,\n          plaintext\n        ];\n        return doVerify(SigStructure, verifier, alg, sig)\n          .then(() => {\n            return plaintext;\n          });\n      } else {\n        const externalAAD = verifier.externalAAD || EMPTY_BUFFER;\n\n        const alg = getCommonParameter(p, u, common.HeaderParameters.alg);\n        p = (!p.size) ? EMPTY_BUFFER : cbor.encode(p);\n        const SigStructure = [\n          'Signature1',\n          p,\n          externalAAD,\n          plaintext\n        ];\n        return doVerify(SigStructure, verifier, alg, signer, publicKeyPem)\n          .then((verified) => {\n            if (verified) \n              return plaintext;\n            else\n              return undefined;\n          });\n      }\n    });\n};\n"]},"metadata":{},"sourceType":"module"}